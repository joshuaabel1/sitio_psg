{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial-python\ud83d\udc0d","text":"<p>Tutorial para el grupo de estudio de Python\ud83d\udc0d.</p>"},{"location":"#como-nos-organizamos","title":"\u00bfC\u00f3mo nos organizamos? \ud83d\udc4d","text":"<p>La idea principal es que podamos aprender entre todos este lindo lenguaje!</p> <p>La metodolog\u00eda que usamos es la siguiente:</p> <ul> <li>\ud83d\udce2 Estaremos utilizando como medio de comunicaci\u00f3n el canal del grupo de estudio en FrontendCaf\u00e9:</li> <li>\ud83d\udcaa Cada semana repasaremos teor\u00eda propuesta para las siguientes sesiones</li> <li>\ud83c\udfc3\u200d\u2642\ufe0f Daremos ejercicios para reforzar los temas y crearemos un proyecto evolutivo a medida que avancemos las sesiones</li> </ul>"},{"location":"#material-de-referencia","title":"Material de referencia \ud83d\udcda","text":"<p>En el grupo usaremos los siguientes recursos recomendados:</p> <ul> <li>Python - W3Schools</li> <li>Programaci\u00f3n con Python</li> <li>Python Cheatsheet en ingles</li> <li>Roadmap</li> </ul>"},{"location":"#requisitos","title":"Requisitos \ud83d\udccb","text":"<p>Bueno, para poder avanzar con la practica del grupo debemos conseguir unos requisitos simples.</p>"},{"location":"#cuentas","title":"Cuentas \ud83d\udcdd","text":"<ul> <li>Github - Donde vamos a estar subiendo los ejercicios</li> <li>Discord - Para poder comunicarnos</li> <li>Codewars - Para realizar ejercicios</li> </ul>"},{"location":"#software","title":"Software \ud83e\uddf0","text":"<ul> <li>Git - Para poder clonar el repositorio y subir los ejercicios</li> <li>Python - Nuestro lenguaje de programaci\u00f3n</li> </ul>"},{"location":"#que-veremos-en-el-grupo","title":"Que veremos en el grupo? \ud83d\udcda:","text":"Teor\u00eda Practicas Tips Python Variables class 1 Types Loops class 2 Operators Conditionals (if, elif, else) class 3 Exceptions class 4 Functions class 5 Lambdas Datastructures (List, tuples, sets y dictionaries) class 6 List, Dicts Comprehensions class 7 POO class 8 Class Modules class 9 Virtual environments Test (doctest, pytest) class 10 Github Frameworks (django)"},{"location":"#contribuidores","title":"\u2728 Contribuidores","text":"Joshua Abel\ud83d\udcd6\ud83d\udcbb\ud83e\uddd1\u200d\ud83c\udfeb\ud83d\udcc6 The Y3rb4\ud83d\udcd6 Jonathan Dyallo\ud83d\udcd6"},{"location":"Summaries/classes_1/","title":"Classes 1","text":""},{"location":"Summaries/classes_1/#variables","title":"Variables:","text":""},{"location":"Summaries/classes_1/#que-son","title":"Que son?","text":"<p>En Python, una variable es un nombre que se utiliza para referirse a un espacio en la memoria del ordenador donde se puede almacenar un valor. Ese valor puede ser un n\u00famero, una cadena de texto, una lista, un diccionario, un objeto, o cualquier otro tipo de dato que Python soporte.</p>"},{"location":"Summaries/classes_1/#como-puedo-asignar-un-valor-a-una-variable-en-python","title":"C\u00f3mo puedo asignar un valor a una variable en Python?","text":"<p>Asignar un valor a una variable en Python es muy sencillo. Utilizas el s\u00edmbolo igual (=) para asignar un valor a un nombre de variable. Aqu\u00ed hay algunos ejemplos:</p> <pre><code>\n# Asignando un n\u00famero entero a una variable\nmi_numero = 5\n\n# Asignando un n\u00famero de punto flotante a una variable\nmi_flotante = 3.14\n\n# Asignando una cadena de texto a una variable\nmi_texto = \"Hola, Mundo!\"\n\n# Asignando una lista a una variable\nmi_lista = [1, 2, 3, 4, 5]\n\n# Asignando un diccionario a una variable\nmi_diccionario = {\"clave\": \"valor\", \"nombre\": \"Juan\", \"edad\": 30}\n\n</code></pre>"},{"location":"Summaries/classes_1/#como-usarlas","title":"Como usarlas?","text":"<p>1) Asignar valores a las variables: Para guardar un valor en una variable, usa el signo igual (=).</p> <pre><code>a = 10          # Asigna el valor 10 a la variable a\nnombre = \"Ana\"  # Asigna la cadena \"Ana\" a la variable nombre\n</code></pre> <p>2) Realizar operaciones con variables: Puedes realizar operaciones matem\u00e1ticas y de otro tipo utilizando las variables.</p> <pre><code>x = 5\ny = 3\nsuma = x + y          # Suma los valores de x e y, guarda el resultado en suma\nproducto = x * y      # Multiplica los valores de x e y y guarda el resultado en producto\nmensaje = \"Hola, \" + nombre  # Concatena la cadena \"Hola, \" con el valor de la variable nombre\n\n</code></pre> <p>3) Usar variables en condiciones: Puedes usar variables en declaraciones condicionales para controlar el flujo del programa.</p> <pre><code>temperatura = 18\nif temperatura &lt; 20:\n    print(\"Esta fresco\")\nelse:\n    print(\"Hace calor\")\n\n</code></pre> <p>4) Pasar variables a funciones: Las variables tambi\u00e9n pueden ser pasadas como argumentos a funciones.</p> <pre><code>def saludo(nombre):\n    return \"Hola, \" + nombre\n\npersona = \"Carlos\"\nmensaje = saludo(persona)  # Pasa la variable persona como argumento a la funci\u00f3n saludo\nprint(mensaje)\n</code></pre> <p>5) Modificar el valor de una variable: Puedes cambiar el valor de una variable reasign\u00e1ndola.</p> <pre><code>contador = 0           # Asigna 0 a la variable contador\ncontador = contador + 1  # Incrementa el valor de contador en 1\ncontador += 1            # Otra forma de incrementar el valor de contador en 1\n</code></pre> <p>6) Usar variables en bucles: Las variables son \u00fatiles para controlar el flujo en bucles, como el bucle for o while.</p>"},{"location":"Summaries/classes_1/#encuestas","title":"encuestas:","text":""},{"location":"Summaries/classes_1/#tipos","title":"Tipos :","text":""},{"location":"Summaries/classes_1/#que-son-los-tipos-de-datos","title":"Que son los tipos de datos?","text":"<p>En Python, los tipos de datos son categor\u00edas que te permiten saber qu\u00e9 clase de valor puede tener una variable y qu\u00e9 operaciones se pueden realizar con ella.</p> <p>1) Representar diferentes tipos de informaci\u00f3n: Cada tipo de dato te permite representar un tipo espec\u00edfico de informaci\u00f3n. Por ejemplo, si necesitas almacenar la edad de una persona, usar\u00edas un n\u00famero entero (int), mientras que si necesitas almacenar su nombre, usar\u00edas una cadena de texto (str).</p> <p>2) Definir las operaciones permitidas: Los tipos de datos determinan qu\u00e9 operaciones pueden realizarse con los valores. Por ejemplo, puedes sumar y restar n\u00fameros, pero no puedes hacer eso con cadenas de texto. En cambio, con cadenas de texto, puedes realizar operaciones como concatenaci\u00f3n.</p> <p>3) Mejorar la legibilidad y mantenimiento del c\u00f3digo: Al usar tipos de datos apropiados, haces que el c\u00f3digo sea m\u00e1s comprensible y f\u00e1cil de mantener, porque otros desarrolladores (o t\u00fa mismo en el futuro) podr\u00e1n entender qu\u00e9 tipo de informaci\u00f3n se supone que debe contener cada variable.</p> <p>4) Manejo de errores: Los tipos de datos ayudan a capturar errores en tiempo de ejecuci\u00f3n. Si intentas realizar una operaci\u00f3n no v\u00e1lida con un tipo de dato particular, como dividir una cadena de texto por un n\u00famero, el lenguaje de programaci\u00f3n generalmente arrojar\u00e1 un error, lo que te ayuda a identificar y corregir problemas en tu c\u00f3digo.</p>"},{"location":"Summaries/classes_1/#condiciones","title":"Condiciones:","text":""},{"location":"Summaries/classes_1/#que-son-las-condiciones-y-para-que-sirven-en-python","title":"Que son las condiciones y para que sirven en python?","text":"<p>En programaci\u00f3n, las condiciones son estructuras que permiten que ciertas partes del c\u00f3digo se ejecuten solo si se cumple una determinada condici\u00f3n o conjunto de condiciones. En Python, esto se logra principalmente utilizando las declaraciones if, elif y else.</p> <p>if: Esta declaraci\u00f3n eval\u00faa una expresi\u00f3n, y si la expresi\u00f3n es verdadera, entonces el bloque de c\u00f3digo indentado debajo de ella se ejecutar\u00e1.</p> <pre><code>\nedad = 18\nif edad &gt;= 18:\n    print(\"Eres mayor de edad.\")\n\n</code></pre> <p>si la variable edad es igual o mayor que 18, se imprimir\u00e1 \"Eres mayor de edad\".</p> <p>elif: Es una abreviatura de \"else if\". Se utiliza para comprobar m\u00faltiples expresiones en una sola estructura if. Si la condici\u00f3n en la declaraci\u00f3n if es falsa, entonces Python verifica la condici\u00f3n en la declaraci\u00f3n elif.</p> <pre><code>\nnumero = 15\nif numero &gt; 20:\n    print(\"El n\u00famero es mayor que 20.\")\nelif numero &gt; 10:\n    print(\"El n\u00famero es mayor que 10 pero no mayor que 20.\")\n\n</code></pre> <p>como numero no es mayor que 20, pero s\u00ed es mayor que 10, se imprimir\u00e1 \"El n\u00famero es mayor que 10 pero no mayor que 20\".</p> <p>else: Captura cualquier caso que no haya sido capturado por las declaraciones if y elif anteriores. No necesita una condici\u00f3n; simplemente se ejecuta si ninguna de las condiciones anteriores fue verdadera.</p> <pre><code>\ntemperatura = 15\nif temperatura &gt; 25:\n    print(\"Hace calor.\")\nelse:\n    print(\"No hace calor.\")\n</code></pre> <p>como la temperatura no es mayor que 25, se imprimir\u00e1 \"No hace calor\".</p> <p>Las condiciones son cruciales para controlar el flujo de un programa. Permiten que el programa tome decisiones, realice acciones diferentes en funci\u00f3n de la entrada del usuario, responda a eventos en tiempo real y mucho m\u00e1s.</p>"},{"location":"Summaries/classes_2/","title":"Classes 2","text":""},{"location":"Summaries/classes_2/#bucles","title":"Bucles:","text":"<p>En Python, un bucle es una estructura de control que permite repetir una serie de instrucciones varias veces. Los bucles son \u00fatiles cuando queremos realizar una acci\u00f3n o conjunto de acciones de manera repetitiva, sin tener que escribir el mismo c\u00f3digo una y otra vez.</p> <p>Hay dos tipos de bucles en Python: el bucle \"for\" y el bucle \"while\".</p> <p>1- Bucle \"for\": Se utiliza cuando se conoce el n\u00famero exacto de iteraciones que se deben realizar. El bucle \"for\" itera sobre una secuencia (como una lista, una cadena de caracteres o una tupla) y ejecuta el bloque de c\u00f3digo correspondiente para cada elemento de la secuencia. Aqu\u00ed tienes un ejemplo de bucle \"for\":</p> <pre><code>frutas = [\"manzana\", \"banana\", \"cereza\"]\nfor fruta in frutas:\n    print(fruta)\n</code></pre> <p>Aca vamos recorrer y imprimir cada elemento de la lista frutas.</p> <p>Bucle \"for\":</p> <ul> <li>Se utiliza cuando se conoce el n\u00famero exacto de iteraciones que se deben realizar.</li> <li>Itera sobre una secuencia predefinida, como una lista, una cadena de caracteres o una tupla.</li> <li>Ejecuta el bloque de c\u00f3digo correspondiente para cada elemento de la secuencia.</li> <li>La variable de iteraci\u00f3n toma autom\u00e1ticamente el valor de cada elemento de la secuencia en cada iteraci\u00f3n.</li> <li>Es \u00fatil para recorrer y procesar todos los elementos de una secuencia o realizar una tarea repetitiva un n\u00famero fijo de veces.</li> </ul> <p>2- Bucle \"while\": Se utiliza cuando no se conoce el n\u00famero exacto de iteraciones y se desea repetir un bloque de c\u00f3digo mientras se cumpla una condici\u00f3n. El bucle \"while\" ejecuta el bloque de c\u00f3digo siempre que la condici\u00f3n sea verdadera. Aqu\u00ed tienes un ejemplo de bucle \"while\":</p> <pre><code>contador = 0\nwhile contador &lt; 5:\n    print(contador)\n    contador += 1\n</code></pre> <p>En este ejemplo, el bucle se repetir\u00e1 mientras contador sea menor que 5. En cada iteraci\u00f3n, se imprimir\u00e1 el valor actual de contador y luego se incrementar\u00e1 en 1.</p> <p>Bucle \"while\":</p> <ul> <li>Se utiliza cuando no se conoce el n\u00famero exacto de iteraciones y se desea repetir un bloque de c\u00f3digo mientras se cumpla una   condici\u00f3n espec\u00edfica.</li> <li>La condici\u00f3n se verifica antes de cada iteraci\u00f3n. Si es verdadera, el bloque de c\u00f3digo se ejecuta; si es falsa, el bucle se   detiene.</li> <li>La variable de control debe actualizarse dentro del bucle para evitar un bucle infinito.</li> </ul>"},{"location":"Summaries/classes_3/","title":"Classes 3","text":""},{"location":"Summaries/classes_3/#colecciones","title":"Colecciones:","text":""},{"location":"Summaries/classes_3/#listas","title":"listas:","text":"<p>Una lista en Python es una estructura de datos que se utiliza para almacenar m\u00faltiples elementos en una \u00fanica variable. Las listas son uno de los cuatro tipos de datos incorporados en Python que se utilizan para almacenar colecciones de datos, los otros tres son Tuple, Set y Dictionary.</p> <p>Las listas en Python tienen las siguientes caracter\u00edsticas:</p> <ol> <li> <p>Ordenadas: Las listas mantienen un orden espec\u00edfico. Es decir, los elementos en una lista aparecen en un orden espec\u00edfico. Por ejemplo, la lista <code>[\"manzana\", \"pl\u00e1tano\", \"cereza\"]</code> siempre mantendr\u00e1 ese orden a menos que se modifique expl\u00edcitamente.</p> </li> <li> <p>Modificables (Mutables): A diferencia de las tuplas en Python, las listas pueden ser modificadas despu\u00e9s de su creaci\u00f3n. Puedes agregar, eliminar y cambiar elementos de la lista.</p> </li> <li> <p>Permiten duplicados: Las listas permiten elementos duplicados. Por ejemplo, <code>[\"manzana\", \"pl\u00e1tano\", \"cereza\", \"manzana\"]</code> es una lista v\u00e1lida.</p> </li> </ol> <p>Una lista se crea colocando todos los elementos (elementos) dentro de corchetes <code>[]</code>, separados por comas. Por ejemplo:</p> <pre><code>frutas = [\"manzana\", \"pl\u00e1tano\", \"cereza\"]\n</code></pre> <p>Puedes acceder a los elementos de la lista por su \u00edndice, comenzando por 0 para el primer elemento. Por ejemplo, <code>frutas[0]</code> devolver\u00e1 <code>\"manzana\"</code>.</p> <p>Las listas tambi\u00e9n soportan una serie de m\u00e9todos para manipular su contenido, como <code>append()</code> para agregar elementos, <code>remove()</code> para eliminar elementos, <code>sort()</code> para ordenar la lista, entre otros.</p> <pre><code>frutas = [\"manzana\", \"banana\", \"cereza\", \"durazno\", \"frambuesa\"]\n</code></pre> <p>Acceder a un \u00edndice espec\u00edfico: Para acceder a un elemento de la lista, usamos su \u00edndice de la siguiente manera:</p> <pre><code>print(frutas[1])  # Salida: banana\n</code></pre> <p>Acceder a un rango de \u00edndices: Para acceder a varios elementos de la lista a la vez, podemos usar el concepto de \"slicing\". Por ejemplo, si queremos acceder desde el \u00edndice 1 al \u00edndice 3:</p> <pre><code>print(frutas[::-1])  # Salida: ['frambuesa', 'durazno', 'cereza', 'banana', 'manzana']\n</code></pre> <p>Las listas en Python proporcionan varios m\u00e9todos para manipular y trabajar con los datos. </p> <ol> <li>append(elemento): Agrega un elemento al final de la lista.</li> </ol> <pre><code>lista = [1, 2, 3]\nlista.append(4)\nprint(lista)  # Salida: [1, 2, 3, 4]\n</code></pre> <ol> <li>extend(iterable): Extiende la lista agregando todos los elementos del iterable (otra lista, tupla, conjunto, etc.)</li> </ol> <pre><code>lista1 = [1, 2, 3]\nlista2 = [4, 5, 6]\nlista1.extend(lista2)\nprint(lista1)  # Salida: [1, 2, 3, 4, 5, 6]\n</code></pre> <ol> <li>insert(indice, elemento): Inserta un elemento en una posici\u00f3n espec\u00edfica en la lista. El primer argumento es el \u00edndice del elemento antes del cual se insertar\u00e1.</li> </ol> <pre><code>lista = [1, 2, 4]\nlista.insert(2, 3)\nprint(lista)  # Salida: [1, 2, 3, 4]\n</code></pre> <ol> <li>remove(elemento): Elimina el primer elemento de la lista que coincida con el argumento.</li> </ol> <pre><code>lista = [1, 2, 3, 2]\nlista.remove(2)\nprint(lista)  # Salida: [1, 3, 2]\n</code></pre> <ol> <li>pop(indice): Elimina el elemento en una posici\u00f3n espec\u00edfica en la lista y lo devuelve. Si no se especifica un \u00edndice, pop() elimina y devuelve el \u00faltimo elemento de la lista.</li> </ol> <pre><code>lista = [1, 2, 3, 4]\nelemento_eliminado = lista.pop(1)\nprint(lista)  # Salida: [1, 3, 4]\nprint(elemento_eliminado)  # Salida: 2\n</code></pre>"},{"location":"Summaries/classes_3/#tuplas","title":"tuplas:","text":"<p>Las tuplas en Python son estructuras de datos que se utilizan para almacenar varios elementos en una \u00fanica variable.</p> <ol> <li> <p>Inmutables: A diferencia de las listas, las tuplas son inmutables. Esto significa que, una vez que una tupla es creada, no puedes cambiar sus elementos ni su tama\u00f1o. </p> </li> <li> <p>Ordenadas: Al igual que las listas, las tuplas mantienen un orden espec\u00edfico. Es decir, los elementos en una tupla aparecen en un orden espec\u00edfico.</p> </li> <li> <p>Permiten duplicados: Las tuplas permiten elementos duplicados. </p> </li> </ol> <p>Una tupla se crea colocando todos los elementos (\u00edtems) dentro de par\u00e9ntesis <code>()</code>, separados por comas. Por ejemplo:</p> <pre><code>frutas = (\"manzana\", \"banano\", \"cereza\")\n</code></pre> <p>Puedes acceder a los elementos de la tupla usando su \u00edndice, que comienza en 0 para el primer elemento. Por ejemplo, <code>frutas[0]</code> devolver\u00eda <code>\"manzana\"</code>.</p> <p>A pesar de que las tuplas son inmutables, puedes tomar porciones de las tuplas existentes para crear nuevas tuplas. Tambi\u00e9n puedes concatenar tuplas para formar nuevas. Aqu\u00ed un ejemplo de cada caso:</p> <pre><code># Definimos una tupla\nnumeros = (1, 2, 3, 4, 5, 6)\n\n# Tomar una porci\u00f3n de la tupla\nsub_tupla = numeros[1:4]  # Esto es (2, 3, 4)\n\n# Concatenar tuplas\ntupla_concatenada = numeros + sub_tupla  # Esto es (1, 2, 3, 4, 5, 6, 2, 3, 4)\n</code></pre>"},{"location":"Summaries/classes_3/#sets","title":"Sets:","text":"<p>Los sets en Python son una colecci\u00f3n de elementos \u00fanicos, no ordenados y mutables. Son similares a las listas y las tuplas.</p> <ol> <li> <p>No ordenados: Los sets no mantienen un orden espec\u00edfico de los elementos. Cuando imprimes un set, los elementos pueden aparecer en cualquier orden, y el orden puede cambiar en diferentes ejecuciones del mismo c\u00f3digo.</p> </li> <li> <p>Mutables: Puedes a\u00f1adir y eliminar elementos de un set despu\u00e9s de su creaci\u00f3n.</p> </li> <li> <p>No permiten duplicados: Cada elemento en un set es \u00fanico. Si tratas de a\u00f1adir un elemento que ya existe en el set, Python simplemente lo ignorar\u00e1.</p> </li> </ol> <p>Un set se crea utilizando llaves <code>{}</code> o la funci\u00f3n <code>set()</code>. Por ejemplo:</p> <pre><code>frutas = {\"manzana\", \"banano\", \"cereza\"}\n</code></pre> <p>O si quieres crear un set vac\u00edo:</p> <pre><code>s = set()\n</code></pre> <p>Nota: No puedes crear un set vac\u00edo con <code>{}</code> porque Python lo interpretar\u00e1 como un diccionario.</p> <p>Puedes a\u00f1adir elementos a un set utilizando el m\u00e9todo <code>add()</code> y puedes eliminar elementos utilizando el m\u00e9todo <code>remove()</code>. Por ejemplo:</p> <pre><code>s = {1, 2, 3}\ns.add(4)\nprint(s)  # Salida: {1, 2, 3, 4}\n\ns.remove(1)\nprint(s)  # Salida: {2, 3, 4}\n</code></pre> <p>Los sets tambi\u00e9n soportan operaciones matem\u00e1ticas como la uni\u00f3n, intersecci\u00f3n, diferencia y diferencia sim\u00e9trica. Por ejemplo, si tienes dos sets:</p> <pre><code>s1 = {1, 2, 3}\ns2 = {2, 3, 4}\n</code></pre> <p>Entonces puedes realizar operaciones como:</p> <pre><code>print(s1.union(s2))  # Salida: {1, 2, 3, 4}\nprint(s1.intersection(s2))  # Salida: {2, 3}\nprint(s1.difference(s2))  # Salida: {1}\nprint(s1.symmetric_difference(s2))  # Salida: {1, 4}\n</code></pre>"},{"location":"Summaries/classes_3/#dicts","title":"dicts:","text":"<p>Un diccionario en Python es una estructura de datos no ordenada y mutable que almacena pares de valores: claves y valores. A cada clave le corresponde un valor, y las claves dentro de un diccionario deben ser \u00fanicas. Aqu\u00ed algunas caracter\u00edsticas de los diccionarios:</p> <ol> <li> <p>No ordenados: Al igual que los sets, los diccionarios no mantienen un orden espec\u00edfico para sus elementos.</p> </li> <li> <p>Mutables: Puedes cambiar el valor de una clave existente y puedes a\u00f1adir o eliminar pares de clave-valor despu\u00e9s de que el diccionario se ha creado.</p> </li> <li> <p>Indexados por sus claves: A diferencia de las listas y las tuplas, que est\u00e1n indexadas por un rango de n\u00fameros, los diccionarios est\u00e1n indexados por sus claves.</p> </li> </ol> <p>Un diccionario se crea usando llaves <code>{}</code>, con los pares clave-valor separados por dos puntos <code>:</code>. Por ejemplo:</p> <pre><code>mi_diccionario = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Madrid\"}\n</code></pre> <p>En este ejemplo, \"nombre\", \"edad\", y \"ciudad\" son las claves, y \"Juan\", 30, y \"Madrid\" son sus respectivos valores.</p> <p>Para acceder a un valor en un diccionario, utilizas la clave correspondiente. Por ejemplo:</p> <pre><code>print(mi_diccionario[\"nombre\"])  # Salida: Juan\n</code></pre> <p>Para a\u00f1adir un nuevo par clave-valor al diccionario, simplemente asignas un valor a una nueva clave:</p> <pre><code>mi_diccionario[\"ocupacion\"] = \"Ingeniero\"\nprint(mi_diccionario)  # Salida: {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Madrid', 'ocupacion': 'Ingeniero'}\n</code></pre> <p>Y para eliminar un par clave-valor del diccionario, puedes usar la declaraci\u00f3n <code>del</code>:</p> <pre><code>del mi_diccionario[\"edad\"]\nprint(mi_diccionario)  # Salida: {'nombre': 'Juan', 'ciudad': 'Madrid', 'ocupacion': 'Ingeniero'}\n</code></pre> <p>Los diccionarios son muy \u00fatiles cuando necesitas asociar valores con claves espec\u00edficas, como cuando almacenas propiedades de un objeto en particular.</p>"},{"location":"Summaries/classes_3/#excepciones","title":"excepciones:","text":"<p>En Python, las excepciones son errores que ocurren durante la ejecuci\u00f3n del programa. Cuando ocurre una excepci\u00f3n, la ejecuci\u00f3n del programa se interrumpe. Python proporciona varias excepciones incorporadas, como <code>IndexError</code>, <code>TypeError</code>, <code>ValueError</code>, etc., y tambi\u00e9n permite crear excepciones personalizadas.</p> <p>Por ejemplo, <code>IndexError</code> es una excepci\u00f3n incorporada que se lanza cuando intentas acceder a un \u00edndice que est\u00e1 fuera del rango v\u00e1lido en una secuencia, como una lista o una tupla. </p> <p>ejemplo de c\u00f3mo podr\u00eda ocurrir un <code>IndexError</code>:</p> <pre><code>lista = [1, 2, 3]\nprint(lista[3])  # Lanza un IndexError porque los \u00edndices v\u00e1lidos son 0, 1, 2\n</code></pre> <p>Para manejar excepciones en Python, puedes usar una estructura <code>try/except</code>. El c\u00f3digo que podr\u00eda lanzar una excepci\u00f3n se coloca dentro del bloque <code>try</code>, y el c\u00f3digo que maneja la excepci\u00f3n se coloca dentro del bloque <code>except</code>. </p> <p>un ejemplo de c\u00f3mo manejar un <code>IndexError</code>:</p> <pre><code>lista = [1, 2, 3]\ntry:\n    print(lista[3])  # Intenta imprimir un elemento fuera del rango\nexcept IndexError:\n    print(\"\u00cdndice fuera de rango\")  # Maneja el error e imprime un mensaje de error\n</code></pre> <p>En este ejemplo, cuando se produce un <code>IndexError</code>, el programa no se detiene. En lugar de eso, imprime \"\u00cdndice fuera de rango\" y contin\u00faa con la ejecuci\u00f3n del programa.</p> <p>Claro, aqu\u00ed tienes un ejemplo en el que se solicita un \u00edndice al usuario a trav\u00e9s de un <code>input()</code>, y se manejan las excepciones <code>IndexError</code> y <code>ValueError</code>:</p> <pre><code>lista = [1, 2, 3]\n\ntry:\n    indice = int(input(\"Ingresa un \u00edndice para la lista: \"))\n    print(lista[indice])\nexcept IndexError:\n    print(\"Error: \u00cdndice fuera de rango.\")\nexcept ValueError:\n    print(\"Error: No ingresaste un n\u00famero entero v\u00e1lido.\")\n</code></pre> <p>En este c\u00f3digo, el programa solicita un \u00edndice al usuario. Intenta convertir el input del usuario en un entero y usarlo como \u00edndice para la lista. </p> <p>Si el usuario ingresa un n\u00famero que est\u00e1 fuera del rango de los \u00edndices de la lista, se lanza un <code>IndexError</code>, que se maneja imprimiendo \"Error: \u00cdndice fuera de rango.\"</p> <p>Si el usuario ingresa algo que no puede ser convertido en un n\u00famero entero (como un string de texto), <code>int(input())</code> lanza un <code>ValueError</code>. Este error se maneja imprimiendo \"Error: No ingresaste un n\u00famero entero v\u00e1lido.\"</p> <p>De esta forma, el programa es capaz de manejar estos errores de forma elegante y proporcionar un feedback \u00fatil al usuario.</p>"},{"location":"exercises/codewars/","title":"Codewars","text":""},{"location":"exercises/codewars/#ejercicios","title":"Ejercicios:","text":"<p>Estos los vamos a sacar de codewars y solucionarlos en la plataforma, voy a seleccionar los que den con las practicas que tuvimos para reforzar conocimientos.</p>"},{"location":"exercises/codewars/#cadenas","title":"Cadenas:","text":"<p>ejercicio 1</p> <p>ejercicio 2</p> <p>ejercicio 3</p> <p>ejercicio 4</p> <p>ejercicio 5</p> <p>ejercicio 6</p> <p>ejercicio 7</p> <p>ejercicio 8</p> <p>ejercicio 9</p> <p>ejercicio 10</p>"},{"location":"exercises/codewars/#operadores","title":"Operadores:","text":"<p>ejercicio 1</p> <p>ejercicio 2</p> <p>ejercicio 3</p> <p>ejercicio 4</p> <p>ejercicio 5</p> <p>ejercicio 6</p> <p>ejercicio 7</p> <p>ejercicio 8</p> <p>ejercicio 9</p> <p>ejercicio 10</p>"},{"location":"exercises/codewars/#listas","title":"Listas:","text":"<p>ejercicio 1</p> <p>ejercicio 2</p> <p>ejercicio 3</p> <p>ejercicio 4</p> <p>ejercicio 5</p> <p>ejercicio 6</p> <p>ejercicio 7</p> <p>ejercicio 8</p> <p>ejercicio 9</p> <p>ejercicio 10</p>"},{"location":"exercises/codewars/#bucles-for","title":"Bucles for:","text":"<p>ejercicio 1</p> <p>ejercicio 2</p> <p>ejercicio 3</p> <p>ejercicio 4</p> <p>ejercicio 5</p> <p>ejercicio 6</p>"},{"location":"practices/class_1/","title":"Class 1","text":"<pre><code>\n\"\"\"\nCLASE 1\n\nCubre tips, variables y types.\n\n\"\"\"\n\n# Aca definimos varias varibles de distintos tipos.\n\ngreeting, number, float_number = \"Hello word\", 2, 2.11\n\n# En este caso definimos la variable y su tipo, cuando definimos una variable \n# en Python se ocupan 2 espacios uno para nuestro variable y su valor y otro  \n# para hace referencia a su tipo.\n\nname:str = \"Juan\"\n\n# Las anotaciones de tipo nos permiten acceder a los m\u00e9todos correspondientes\n# de cada tipo de datos y nos da informaci\u00f3n sobre el tipo de datos esperado.\n\nprint(greeting.lower().index(\"h\"), number.__str__(), float_number.__int__())\n\n# Esto nos permite poder desde las variable ver que en Python todo es un objeto.\n\n# Tambien esto nos obliga a respetar el tipo de dato.\n\n# print(greeting + number)\n\n# Esto no va a dovolver este error (TypeError: can only concatenate str (not \"int\") to str)\n# El tipado en Python puede ayudar a mejorar la calidad del c\u00f3digo, hacer que sea m\u00e1s \n# f\u00e1cil de entender y mantener, y facilitar la colaboraci\u00f3n en equipo.\n\nprint(greeting + str(number))\n\n# La manera correcta seria convirtiendo el entero a una cadena, esto se llama concatenar.\n# str es parte de las funciones integradas de Python.\n\n# Tambien podemos usar format string.\n\nprint(f\"{greeting}{number}\")\n\nlist1 = [1, 2, 5, 7]\nlist3 = [3, 8, 10]\n\n# El c\u00f3digo concatenar\u00e1 las dos listas list1y, list3\n\nprint(list1 + list3)\n\n# Esto se debe a que el + operador se usa \n# para combinar las dos listas en una sola lista,\n# donde los elementos de list3se agregan al final de list1.\n\n# Ejercicios:\n\n\"\"\"\n\nDeclarar variables del tipo int, str, bool y float sumarlas, multiplicarlas\ny dividirlas.\ninvestigar cuales son las operaciones no permitidas entre ellas y guardar los errores \nque nos devuelven.\n\n\"\"\"\n\n</code></pre>"},{"location":"practices/class_2/","title":"Class 2","text":"<pre><code>\n\"\"\"\nCLASE 2\n\nCubre loops.\n\n\"\"\"\n\n# Para utilizar un bucle for en Python, es com\u00fan trabajar con una secuencia de elementos, \n# que puede ser una lista, tupla, cadena de texto u otro objeto iterable. \n# En lugar de trabajar con \u00edndices, como en algunos otros lenguajes de programaci\u00f3n, \n# en Python es posible recorrer directamente los elementos de una secuencia utilizando \n# el bucle for.\n\n# Lista:\n\nfruits = [\"manzana\", \"banana\", \"kiwi\", \"naranja\"]\n\nfor fruit in fruits:\n    print(fruit)\n\n\n# Este bucle for recorre la lista de frutas y \n# en cada iteraci\u00f3n imprime el valor de la variable fruta.\n\n\n# Range:\n\nfor i in range(5):\n    print(i)\n\n\n# Este bucle for recorre los valores del rango\n# range(5) (0, 1, 2, 3, 4) y en cada iteraci\u00f3n imprime el valor de la variable i.\n\n\n# Dicts:\n\nages = {\"Juan\": 25, \"Mar\u00eda\": 30, \"Pedro\": 35}\n\nfor name, age in ages.items():\n    print(name, \"have\", age, \"years\")\n\n\n# Este bucle for recorre el diccionario edades y en cada iteraci\u00f3n imprime el nombre \n# y la edad correspondiente. La funci\u00f3n items permite obtener tanto la clave como el valor \n# del diccionario en cada iteraci\u00f3n.\n\n\n# Aca podemos hacer tareas como multiplicar, sumar y agregar tareas\n# en cada iteracion.\n\n# Ejemplo:\n\nfor i in range(5):\n    print(i**2)\n\n\n# Al igual que con el bucle for, para utilizar un bucle while en Python, \n# necesitamos definir una condici\u00f3n que se eval\u00fae como True o False. \n# Mientras la condici\u00f3n sea True, el c\u00f3digo dentro del bucle se ejecutar\u00e1 repetidamente.\n\ncount = 1\n\nwhile count &lt;= 5:\n    print(count)\n    count += 1\n\n# En este ejemplo, utilizamos la variable contador para llevar la cuenta de los n\u00fameros\n# que hemos imprimido hasta el momento. La condici\u00f3n contador &lt;= 5 se eval\u00faa en cada \n# iteraci\u00f3n del bucle, y el bucle se ejecuta mientras la condici\u00f3n sea verdadera. \n# En cada iteraci\u00f3n, imprimimos el valor actual de contador, y luego incrementamos \n# su valor en 1 con contador += 1.\n\n# A diferencia del bucle for, el bucle while no est\u00e1 dise\u00f1ado espec\u00edficamente \n# para recorrer elementos de una secuencia. En lugar de eso, podemos utilizar \n# un bucle while para ejecutar un bloque de c\u00f3digo mientras se cumpla una cierta condici\u00f3n. \n# En algunos casos, podemos utilizar un contador para controlar el n\u00famero de \n# iteraciones del bucle.\n\nentry = \"\"\n\nwhile entry != \"salir\":\n    entry = input(\"Ingresa un valor (escribe 'salir' para terminar): \")\n    print(\"Ingresaste:\", entry)\n\nprint(\"Fin del programa\")\n\n# Este bucle while solicita una entrada de usuario utilizando la funci\u00f3n input(). \n# El bucle se ejecuta mientras la entrada del usuario no sea igual a la cadena de \n# texto \"salir\". En cada iteraci\u00f3n, se imprime la entrada del usuario utilizando la funci\u00f3n\n# print(). Cuando el usuario ingresa la palabra \"salir\", el bucle se detiene y se imprime \n# el mensaje \"Fin del programa\".\n\n\nlimit = 10\nsum = 0\ncount = 1\n\nwhile count &lt;= limit:\n    sum += count\n    count += 1\n\nprint(\"La suma de los n\u00fameros del 1 al\", limit, \"es:\", sum)\n\n# Este bucle while suma los n\u00fameros del 1 al limite utilizando la variable\n# suma y el contador contador. El bucle se ejecuta mientras el valor de contador \n# sea menor o igual que limite.\n\n</code></pre>"},{"location":"practices/class_3/","title":"Class 3","text":"<pre><code>\n\"\"\"\nCLASE 3\n\nCubre operators y conditionals(if, elif y else).\n\n\"\"\"\n\n\"Operadores aritm\u00e9ticos:\"\n\n# Suma\nx = 2 + 3 \n\n# Resta\ny = 5 - 1\n\n# Multiplicaci\u00f3n\nz = x * y \n\n# Divisi\u00f3n\nw = z / x \n\n# M\u00f3dulo (resto de la divisi\u00f3n)\nr = z % y \n\n# Exponenciaci\u00f3n\ne = 2 ** 3 \n\n\"Operadores de comparaci\u00f3n:\"\n\n# Igualdad\nx == y \n\n# distinto que\nx != y \n\n# Mayor que\nx &gt; y \n\n# Menor que\nx &lt; y \n\n# Mayor o igual que\nx &gt;= y \n\n# Menor o igual que\nx &lt;= y \n\n\"Operadores l\u00f3gicos:\"\n\n# AND l\u00f3gico\n(x &gt; 0) and (y &lt; 10) \n\n# OR l\u00f3gico\n(x &lt; 0) or (y &gt; 0) \n\n# NOT l\u00f3gico\nnot (x &gt; y) \n\n\"Condicionales:\"\n\n# Sentencia if\n\nx = 5\n\nif x &gt; 0:\n    print(\"x es positivo\")\n\n# Sentencia if-else\n\nx = -2\n\nif x &gt; 0:\n    print(\"x es positivo\")\nelse:\n    print(\"x es negativo o cero\")\n\n# Sentencia if-elif-else\n\nx = 0\n\nif x &gt; 0:\n    print(\"x es positivo\")\nelif x &lt; 0:\n    print(\"x es negativo\")\nelse:\n    print(\"x es cero\")\n\n</code></pre>"},{"location":"practices/class_4/","title":"Class 4","text":"<pre><code>\n\n\"\"\"\nCLASE 4\n\nCubre exceptions.\n\n\"\"\"\n\n# Las excepciones son utilizadas para manejar errores que pueden ocurrir durante\n# la ejecuci\u00f3n de un programa. Aqu\u00ed te muestro algunos ejemplos b\u00e1sicos de excepciones\n#  en Python:\n\n\"Excepci\u00f3n ZeroDivisionError:\"\n\na = 5\nb = 0\n\ntry:\n    c = a / b\nexcept ZeroDivisionError:\n    print(\"Error: divisi\u00f3n por cero\")\n\n\n# En este ejemplo, intentamos dividir a entre b, lo que dar\u00eda como resultado\n# una divisi\u00f3n por cero y producir\u00eda un error ZeroDivisionError. Para manejar \n# esta excepci\u00f3n, utilizamos una sentencia try-except para capturar el error \n# y mostrar un mensaje personalizado.\n\n\"Excepci\u00f3n ValueError:\"\n\nx = input(\"Ingrese un n\u00famero: \")\n\ntry:\n    x = int(x)\nexcept ValueError:\n    print(\"Error: debe ingresar un n\u00famero entero\")\n\n# En este ejemplo, pedimos al usuario que ingrese un n\u00famero a trav\u00e9s de la funci\u00f3n input(). \n# Si el usuario ingresa una cadena de texto que no puede ser convertida a un n\u00famero entero, \n# se producir\u00e1 un error ValueError. Para manejar esta excepci\u00f3n, utilizamos una sentencia \n# try-except para capturar el error y mostrar un mensaje personalizado.\n\n\n\"Excepci\u00f3n FileNotFoundError:\"\n\ntry:\n    file = open(\"archivo.txt\", \"r\")\nexcept FileNotFoundError:\n    print(\"Error: el archivo no existe\")\n\n# En este ejemplo, intentamos abrir un archivo llamado \"archivo.txt\" en modo lectura (\"r\"). \n# Si el archivo no existe en la ruta especificada, se producir\u00e1 un error FileNotFoundError.\n# Para manejar esta excepci\u00f3n, utilizamos una sentencia try-except para capturar el error y \n# mostrar un mensaje personalizado.\n\n</code></pre>"},{"location":"practices/class_5/","title":"Class 5","text":"<pre><code>\n\"\"\"\nCLASE 5\n\nCubre funciones y lambdas.\n\n\"\"\"\n\n# Las funciones son bloques de c\u00f3digo reutilizables que realizan una tarea espec\u00edfica. \n# Aqu\u00ed te muestro algunos ejemplos de funciones b\u00e1sicas en Python:\n\n\"Funci\u00f3n que suma dos n\u00fameros: \"\n\ndef sum(a, b):\n    return a + b\n\nresult = sum(5, 3)\nprint(result)  # salida: 8\n\n# Definimos una funci\u00f3n llamada sum que toma dos argumentos (a y b)\n# y devuelve la suma de estos dos n\u00fameros. Luego, llamamos a la funci\u00f3n y asignamos \n# su resultado a la variable resultado, que luego se imprime en la consola.\n\n\"Funci\u00f3n que devuelve la longitud de una cadena de texto: \"\n\ndef length(string):\n    return len(string)\n\ntext = \"Hola, mundo!\"\nresult = length(text)\nprint(result)  # salida: 12\n\n# Definimos una funci\u00f3n llamada longitud que toma una cadena\n# de texto como argumento y devuelve su longitud utilizando la funci\u00f3n incorporada\n# len(). Luego, llamamos a la funci\u00f3n con una cadena de texto y asignamos su resultado \n# a la variable resultado, que luego se imprime en la consola.\n\n\"Funci\u00f3n que imprime el doble de un n\u00famero: \"\n\ndef double(number):\n    print(number * 2)\n\ndouble(5)  # salida: 10\n\n# Definimos una funci\u00f3n llamada double que toma un n\u00famero como argumento\n# y lo imprime multiplicado por 2. Luego, llamamos a la funci\u00f3n con el argumento 5, \n# lo que imprimir\u00e1 el valor 10 en la consola.\n\n# Las funciones lambda son funciones an\u00f3nimas que se utilizan para realizar tareas simples. \n# Aqu\u00ed te muestro algunos ejemplos de funciones lambda b\u00e1sicas en Python:\n\n\"Funci\u00f3n lambda que devuelve el doble de un n\u00famero: \"\n\n# aca vamos a repetir la primera funcion pero con lambda\n\ndouble = lambda x: x * 2\n\nresult = double(5)\nprint(result)  # salida: 10\n\n\n# Definimos una funci\u00f3n lambda que toma un argumento x y \n# devuelve el double de ese n\u00famero. Luego, asignamos la funci\u00f3n lambda a la \n# variable doble y llamamos a la funci\u00f3n con el argumento 5, lo que asignar\u00e1\n# el valor 10 a la variable resultado.\n\n\"Funci\u00f3n lambda que devuelve la suma de dos n\u00fameros: \"\n\n# Lo mismo que en la anterior funcion repetimos la funcion sum pero como una \n# funcion anonima .\n\nsumm = lambda x, y: x + y\n\nresult = summ(5, 3)\nprint(result)  # salida: 8\n\n# Definimos una funci\u00f3n lambda que toma dos argumentos (x e y) y devuelve\n# la suma de esos dos n\u00fameros. Luego, asignamos la funci\u00f3n lambda a la variable\n# suma y llamamos a la funci\u00f3n con los argumentos 5 y 3, lo que asignar\u00e1 el valor\n# 8 a la variable resultado.\n\n\"Funci\u00f3n lambda que devuelve una lista de n\u00fameros pares: \"\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\npair = list(filter(lambda x: x % 2 == 0, numbers))\nprint(numbers)  # salida: [2, 4, 6, 8]\n\n# Definimos una lista de n\u00fameros numbers y utilizamos la funci\u00f3n filter junto\n# con una funci\u00f3n lambda para filtrar los n\u00fameros pares de la lista. La funci\u00f3n\n# lambda toma un argumento x y devuelve True si x es divisible por 2 \n# (es decir, si es un n\u00famero par). Luego, convertimos el resultado en una lista y \n# lo asignamos a la variable pares, que luego se imprime en la consola.\n\n</code></pre>"},{"location":"practices/class_6/","title":"Class 6","text":"<pre><code>\n\"\"\"\nCLASE 6\n\nCubre datastructures (List, tuples, sets y dictionaries).\n\n\"\"\"\n\n\"Lists: \"\n\n# Crear una lista vac\u00eda:\n\nmy_list = []\n\n# Agregar elementos a la lista:\n\nmy_list.append(\"elemento1\")\nmy_list.append(\"elemento2\")\nmy_list.append(\"elemento3\")\nprint(my_list)  # salida: [\"elemento1\", \"elemento2\", \"elemento3\"]\n\n# Acceder a un elemento de la lista por su \u00edndice:\n\nmy_list = [\"elemento1\", \"elemento2\", \"elemento3\"]\nprint(my_list[0])  # salida: \"elemento1\"\n\n# Cambiar un elemento de la lista por su \u00edndice:\n\nmy_list = [\"elemento1\", \"elemento2\", \"elemento3\"]\nmy_list[1] = \"nuevo_elemento\"\nprint(my_list)  # salida: [\"elemento1\", \"nuevo_elemento\", \"elemento3\"]\n\n# Eliminar el \u00faltimo elemento de la my_list:\n\nmy_list = [\"elemento1\", \"elemento2\", \"elemento3\"]\nmy_list.pop()\nprint(my_list)  # salida: [\"elemento1\", \"elemento2\"]\n\n# Obtener la longitud de la lista:\n\nmy_list = [\"elemento1\", \"elemento2\", \"elemento3\"]\nprint(len(my_list))  # salida: 3\n\n# Ordenar una lista de n\u00fameros:\n\nnumbers = [4, 2, 1, 3, 5]\nnumbers.sort()\nprint(numbers)  # salida: [1, 2, 3, 4, 5]\n\n\n\"Tuplas: \"\n\n# Crear una tupla:\n\ntuples = (1, 2, 3, 4, 5)\n\n# Acceder a un elemento de la tupla por su \u00edndice:\n\ntuples = (1, 2, 3, 4, 5)\nprint(tuples[0])  # salida: 1\n\n# Obtener la longitud de la tupla:\n\ntuples = (1, 2, 3, 4, 5)\nprint(len(tuples))  # salida: 5\n\n# Convertir una tupla en una lista:\n\ntuples = (1, 2, 3, 4, 5)\nlist = list(tuples)\nprint(list)  # salida: [1, 2, 3, 4, 5]\n\n# Convertir una lista en una tupla:\n\nlist = [1, 2, 3, 4, 5]\ntuples = tuple(list)\nprint(tuples)  # salida: (1, 2, 3, 4, 5)\n\n# Unir dos tuplas:\n\ntuples1 = (1, 2, 3)\ntuples2 = (4, 5, 6)\ntuples3 = tuples1 + tuples2\nprint(tuples3)  # salida: (1, 2, 3, 4, 5, 6)\n\n# Contar la cantidad de veces que aparece un elemento en una tupla:\n\ntuples = (1, 2, 3, 4, 5, 5, 5)\ncounter = tuples.count(5)\nprint(counter)  # salida: 3\n\n\n\"Sets: \"\n\n# Crear un set:\n\nmy_set = {1, 2, 3, 4, 5}\n\n# Agregar elementos a un set:\n\nmy_set = {1, 2, 3, 4, 5}\nmy_set.add(6)\nprint(my_set)  # salida: {1, 2, 3, 4, 5, 6}\n\n# Eliminar un elemento de un set:\n\nmy_set = {1, 2, 3, 4, 5}\nmy_set.remove(3)\nprint(my_set)  # salida: {1, 2, 4, 5}\n\n# Unir dos sets:\n\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\nset3 = set1.union(set2)\nprint(set3)  # salida: {1, 2, 3, 4, 5}\n\n# Obtener la intersecci\u00f3n de dos sets:\n\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\nset3 = set1.intersection(set2)\nprint(set3)  # salida: {3}\n\n# Obtener la diferencia de dos sets:\n\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\nset3 = set1.difference(set2)\nprint(set3)  # salida: {1, 2}\n\n# Verificar si un elemento est\u00e1 en un set:\n\nmi_set = {1, 2, 3, 4, 5}\nresult = 3 in mi_set\nprint(result)  # salida: True\n\n\"Dicts: \"\n\n# Crear un diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\n\n# Acceder a un valor por su clave:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\nprint(my_dict[\"edad\"])  # salida: 30\n\n# Agregar una clave-valor al diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\nmy_dict[\"profesion\"] = \"Ingeniero\"\nprint(my_dict)  \n# salida: {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\", \"profesion\": \"Ingeniero\"}\n\n# Eliminar una clave-valor del diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\ndel my_dict[\"ciudad\"]\nprint(my_dict)  # salida: {\"nombre\": \"Juan\", \"edad\": 30}\n\n\n# Obtener las claves de un diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\nkeys = my_dict.keys()\nprint(my_dict)  # salida: [\"nombre\", \"edad\", \"ciudad\"]\n\n# Obtener los valores de un diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\nvalues = my_dict.values()\nprint(my_dict)  # salida: [\"Juan\", 30, \"Lima\"]\n\n# Verificar si una clave est\u00e1 en un diccionario:\n\nmy_dict = {\"nombre\": \"Juan\", \"edad\": 30, \"ciudad\": \"Lima\"}\nresult = \"nombre\" in my_dict\nprint(result)  # salida: True\n\n\n</code></pre>"},{"location":"practices/class_7/","title":"Class 7","text":"<pre><code>\n\"\"\"\nCLASE 7\n\nCubre list, dicts Comprehensions.\n\n\"\"\"\n\n\"Crear una lista a partir de otra lista:\"\n\n# Puedes usar una list comprehension para crear una nueva lista basada\n# en una lista existente. Por ejemplo, si tienes una lista de n\u00fameros y quieres\n# crear una nueva lista con solo los n\u00fameros pares, puedes hacer lo siguiente:\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\npairs_numbers = [num for num in numbers if num % 2 == 0]\n\n# El resultado ser\u00e1 la lista [2, 4, 6, 8, 10].\n\n\n\"Crear una lista a partir de una cadena:\"\n# Puedes usar una list comprehension para crear una lista de caracteres\n# a partir de una cadena. Por ejemplo:\n\nstring = \"Hola mundo\"\nchars = [char for char in string]\n\n# El resultado ser\u00e1 la lista ['H', 'o', 'l', 'a', ' ', 'm', 'u', 'n', 'd', 'o'].\n\n\"Crear una lista de tuplas:\"\n\n# Puedes usar una list comprehension para crear una lista de tuplas a partir\n# de dos listas existentes. Por ejemplo, si tienes dos listas de nombres y edades, \n# puedes crear una lista de tuplas que contenga cada nombre y su respectiva edad\n#  de la siguiente manera:\n\nnames = [\"Juan\", \"Mar\u00eda\", \"Pedro\"]\nages = [25, 30, 40]\ntups = [(names, ages) for name, age in zip(names, ages)]\n\n# El resultado ser\u00e1 la lista [('Juan', 25), ('Mar\u00eda', 30), ('Pedro', 40)].\n\n\"Crear un diccionario a partir de una lista:\"\n\n# Puedes usar un dictionary comprehension para crear un diccionario a partir de una lista.\n# Por ejemplo, si tienes una lista de nombres y quieres crear un diccionario donde cada\n# nombre es una clave y su valor es su longitud, puedes hacer lo siguiente:\n\nnames = [\"Juan\", \"Mar\u00eda\", \"Pedro\"]\ndict_names = {names: len(name) for name in names}\n\n# El resultado ser\u00e1 el diccionario {'Juan': 4, 'Mar\u00eda': 5, 'Pedro': 5}.\n\n# Crear un diccionario a partir de dos listas:\n\n# Puedes usar un dictionary comprehension para crear un diccionario a partir de dos listas.\n# Por ejemplo, si tienes dos listas de nombres y edades, puedes crear un diccionario que\n# contenga cada nombre como clave y su respectiva edad como valor de la siguiente manera:\n\nnames = [\"Juan\", \"Mar\u00eda\", \"Pedro\"]\nages = [25, 30, 40]\ndict = {names[i]: ages[i] for i in range(len(names))}\n\n# El resultado ser\u00e1 el diccionario {'Juan': 25, 'Mar\u00eda': 30, 'Pedro': 40}.\n\n\"Filtrar un diccionario:\"\n\n# Puedes usar un dictionary comprehension para filtrar un diccionario en funci\u00f3n\n# de alguna condici\u00f3n. Por ejemplo, si tienes un diccionario con nombres y edades\n# y quieres crear un nuevo diccionario con solo los nombres de las personas mayores\n# de 30 a\u00f1os, puedes hacer lo siguiente:\n\npeople = {'Juan': 25, 'Mar\u00eda': 30, 'Pedro': 40}\ngreater = {name: age for name, age in people.items() if age &gt; 30}\n\n# El resultado ser\u00e1 el diccionario {'Pedro': 40}.\n\n</code></pre>"},{"location":"practices/class_8/","title":"Class 8","text":"<pre><code>\n\"\"\"\nCLASE 8\n\nCubre POO y class.\n\n\"\"\"\n\nclass Persons:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        print(f\"Hello, my name is {self.name} and I am {self.age} years old.\")\n\n# Crear una instancia de la clase Persons\njuan = Persons(\"Juan\", 25)\n\n# Llamar al m\u00e9todo saludar de la instancia juan\njuan.greet()\n\n# En este ejemplo, se define una clase llamada Persona. La clase tiene dos\n# atributos: nombre y edad, y un m\u00e9todo llamado saludar que imprime una cadena \n# formateada con el nombre y la edad de la persona.\n\n# Luego, se crea una instancia de la clase Persona con el nombre juan y \n# se le asignan valores para sus atributos. Finalmente, se llama al m\u00e9todo\n# saludar de la instancia juan para imprimir el saludo.\n\n\nclass Appliance:\n    def __init__(self, brand, model, price):\n        self.brand = brand\n        self.model = model\n        self.price = price\n\n    def on(self):\n        print(f\"{self.brand} {self.model} turned on.\")\n\n    def off(self):\n        print(f\"{self.brand} {self.model} turned off.\")\n\nclass WashingMachine(Appliance):\n    def __init__(self, brand, model, price, capacity):\n        super().__init__(brand, model, price)\n        self.capacity = capacity\n\n    def wash(self):\n        print(f\"Washing clothes in {self.brand} {self.model}.\")\n\nclass Television(Appliance):\n    def __init__(self, brand, model, price, size):\n        super().__init__(brand, model, price)\n        self.size = size\n\n    def change_channel(self, channel):\n        print(f\"Changing channel to {channel} on {self.brand} {self.model}.\")\n\n\n# En este ejemplo, se define una clase Electrodomestico con atributos marca,\n# modelo y precio, y m\u00e9todos encender y apagar. Luego, se definen dos subclases\n# que heredan de Electrodomestico: Lavadora y Televisor.\n\n# La clase Lavadora tiene un atributo adicional capacidad y un m\u00e9todo lavar, \n# que imprime un mensaje de que se est\u00e1 lavando ropa.\n\n# La clase Televisor tiene un atributo adicional tama\u00f1o y un m\u00e9todo cambiar_canal,\n# que imprime un mensaje de que se est\u00e1 cambiando el canal.\n\n# Al heredar de la clase Electrodomestico, ambas subclases obtienen los m\u00e9todos y \n# atributos definidos en la clase padre, pero tambi\u00e9n pueden agregar sus propios atributos\n# y m\u00e9todos adicionales espec\u00edficos de cada subclase.\n\n</code></pre>"},{"location":"practices/class_9/","title":"Class 9","text":"<pre><code>\n\"\"\"\nCLASES 9\n\nCubre modules y virtual enviroments.\n\n\"\"\"\n\n</code></pre>"},{"location":"practices/test_class_10/","title":"Test class 10","text":"<pre><code>\n\"\"\"\nCLASE 10\n\nCubre test(doctest, pytest).\n\n\"\"\"\nimport doctest\nfrom class_8 import Appliance, WashingMachine, Television\n\n\"pytest: \"\n\n\ndef test_appliance_on(capsys):\n    e = Appliance('LG', 'ABC123', 500)\n    e.on()\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"LG ABC123 turned on.\"\n\ndef test_appliance_off(capsys):\n    e = Appliance('LG', 'ABC123', 500)\n    e.off()\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"LG ABC123 turned off.\"\n\ndef test_washingmachine_wash(capsys):\n    l = WashingMachine('Samsung', 'DEF456', 800, 10)\n    l.wash()\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"Washing clothes in Samsung DEF456.\"\n\ndef test_televisor_change_channel(capsys):\n    t = Television('Sony', 'GHI789', 1000, 50)\n    t.change_channel(5)\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"Changing channel to 5 on Sony GHI789.\"\n\n# En estos tests, se definen funciones separadas para cada prueba. \n# Cada funci\u00f3n crea una instancia de la clase correspondiente y \n# llama a uno de sus m\u00e9todos. Luego, la funci\u00f3n assert se usa para verificar\n# que la salida del m\u00e9todo sea igual a un valor esperado.\n\n\"doctest: \"\n\n\ndef length(string):\n    \"\"\"\n    Returns the length of the input string.\n\n    &gt;&gt;&gt; length(\"hello\")\n    5\n    &gt;&gt;&gt; length(\"Python\")\n    6\n    &gt;&gt;&gt; length(\"\")\n    0\n    \"\"\"\n    return len(string)\n\n# En este doctest, se definen tres casos de prueba diferentes usando la \n# sintaxis &gt;&gt;&gt; y .... El primer caso de prueba espera que la funci\u00f3n length()\n# devuelva 5 cuando se le pase la cadena \"hello\" como argumento. El segundo caso\n# de prueba espera que la funci\u00f3n devuelva 6 cuando se le pase la cadena \"Python\".\n# El tercer caso de prueba espera que la funci\u00f3n devuelva 0 cuando se le pase una \n# cadena vac\u00eda.\n\ndef double(num):\n    \"\"\"\n    Returns the input number multiplied by 2.\n\n    &gt;&gt;&gt; double(2)\n    4\n    &gt;&gt;&gt; double(5)\n    10\n    &gt;&gt;&gt; double(-3)\n    -6\n    \"\"\"\n    return num * 2\n\n# En este doctest, se definen tres casos de prueba diferentes que esperan\n# que la funci\u00f3n double() devuelva el resultado correcto cuando se le pase\n# un n\u00famero entero como argumento. El primer caso de prueba espera que la funci\u00f3n\n# devuelva 4 cuando se le pase el n\u00famero 2. El segundo caso de prueba espera que\n# la funci\u00f3n devuelva 10 cuando se le pase el n\u00famero 5. El tercer caso de prueba\n# espera que la funci\u00f3n devuelva -6 cuando se le pase el n\u00famero -3.\n\nif __name__ == '__main__':\n    doctest.testmod()\n\n</code></pre>"},{"location":"theory/class/","title":"Class","text":""},{"location":"theory/class/#clases","title":"Clases:","text":"<p>En Python, las clases son una forma de crear objetos que contienen atributos y m\u00e9todos. Un objeto es una instancia de una clase, y contiene valores para los atributos definidos en la clase, as\u00ed como los m\u00e9todos que se pueden llamar para manipular el objeto.</p> <p>La sintaxis b\u00e1sica para definir una clase en Python es la siguiente:</p> <pre><code>class GenericClass:\n    def __init__(self, arg1, arg2, ...):\n        self.atributo1 = arg1\n        self.atributo2 = arg2\n        ...\n\n    def metodo1(self, arg1, arg2, ...):\n        # codigo del metodo\n\n    def metodo2(self, arg1, arg2, ...):\n        # codigo del metodo\n\n</code></pre> <p>Aqu\u00ed, GenericClass es el nombre que le damos a nuestra clase. El m\u00e9todo __init es el constructor de la clase, que se llama autom\u00e1ticamente cuando se crea un nuevo objeto de la clase. El primer argumento de cualquier m\u00e9todo de una clase es self, que se refiere al objeto en s\u00ed mismo. Los dem\u00e1s argumentos son los que el m\u00e9todo necesita para hacer su trabajo.__</p> <p>Dentro del m\u00e9todo __init, se establecen los atributos del objeto utilizando la sintaxis self.atributo = valor. Los m\u00e9todos de la clase se definen utilizando la sintaxis def metodo(self, arg1, arg2, ...): y luego se escribe el c\u00f3digo del m\u00e9todo.__</p> <p>Para crear un objeto de una clase, se utiliza la sintaxis objeto = GenericClass(arg1, arg2, ...). Esto llama al constructor __init de la clase y devuelve un objeto que se puede manipular utilizando sus atributos y m\u00e9todos.__</p> <pre><code>class Person:\n    def init(self, name, age):\n        self.name = name\n        self.age = age\n\n    def print_information(self):\n        print(f\"My name is {self.name} and I am {self.age} years old.\")\n</code></pre> <p>Podr\u00edamos crear un objeto de esta clase as\u00ed:</p> <pre><code>persona1 = Person(\"Juan\", 25)\n</code></pre> <p>Y luego podr\u00edamos llamar al m\u00e9todo imprimir_informacion as\u00ed:</p> <pre><code>persona1.print_information()\n</code></pre> <p>Esto imprimir\u00eda el mensaje \"Mi nombre es Juan y tengo 25 a\u00f1os.\"</p>"},{"location":"theory/comprehensions/","title":"Comprehensions","text":""},{"location":"theory/comprehensions/#comprensiones","title":"Comprensiones:","text":"<p>En Python, las comprensiones son una forma concisa y legible de crear listas, diccionarios o conjuntos mediante la aplicaci\u00f3n de una expresi\u00f3n a cada elemento de una secuencia o iterador.</p> <p>Existen tres tipos de comprensiones en Python:</p> <p>1) Comprensiones de lista: Se usan para crear una lista a partir de otra secuencia o iterador. La sintaxis b\u00e1sica es:</p> <pre><code>[expresion for elemento in secuencia if condicion]\n</code></pre> <p>Donde expresion es la operaci\u00f3n que se aplica a cada elemento de secuencia, elemento es la variable que representa a cada elemento de la secuencia, y condicion es opcional y se usa para filtrar elementos de la secuencia.</p> <p>Por ejemplo, para crear una lista de los cuadrados de los n\u00fameros del 1 al 10, podr\u00edas escribir:</p> <pre><code>cuadrados = [x**2 for x in range(1, 11)]\n</code></pre> <p>2) Comprensiones de diccionario: Se usan para crear un diccionario a partir de otra secuencia o iterador. La sintaxis b\u00e1sica es:</p> <pre><code>{clave_expresion: valor_expresion for elemento in secuencia if condicion}\n</code></pre> <p>Donde clave_expresion y valor_expresion son las operaciones que se aplican a cada elemento de secuencia para generar las claves y valores del diccionario, elemento es la variable que representa a cada elemento de la secuencia, y condicion es opcional y se usa para filtrar elementos de la secuencia.</p> <p>Por ejemplo, para crear un diccionario que mapea cada letra del alfabeto a su correspondiente n\u00famero de \u00edndice (comenzando desde cero), podr\u00edas escribir:</p> <pre><code>alfabeto = 'abcdefghijklmnopqrstuvwxyz'\nindices = {letra: i for i, letra in enumerate(alfabeto)}\n</code></pre> <p>3) Comprensiones de conjunto: Se usan para crear un conjunto a partir de otra secuencia o iterador. La sintaxis b\u00e1sica es:</p> <pre><code>{expresion for elemento in secuencia if condicion}\n</code></pre> <p>Donde expresion es la operaci\u00f3n que se aplica a cada elemento de secuencia, elemento es la variable que representa a cada elemento de la secuencia, y condicion es opcional y se usa para filtrar elementos de la secuencia.</p> <p>Por ejemplo, para crear un conjunto de los cuadrados de los n\u00fameros impares del 1 al 10, podr\u00edas escribir:</p> <pre><code>cuadrados_impares = {x**2 for x in range(1, 11) if x % 2 != 0}\n</code></pre>"},{"location":"theory/conditionals/","title":"Conditionals","text":""},{"location":"theory/conditionals/#condiciones","title":"Condiciones:","text":"<p>Las condiciones en Python son expresiones booleanas que se eval\u00faan en verdadero o falso. Las expresiones booleanas pueden estar formadas por operadores de comparaci\u00f3n (como &gt;, &lt;, &gt;=, &lt;=, == y !=), operadores l\u00f3gicos (como and, or y not) y variables booleanas.</p> <p>Cuando se eval\u00faa una condici\u00f3n, el resultado es una de las dos posibles opciones: verdadero (True) o falso (False). Dependiendo del resultado de la evaluaci\u00f3n de la condici\u00f3n, se ejecutar\u00e1 un bloque de c\u00f3digo o no.</p> <pre><code>\nif condicion1:\n    # c\u00f3digo a ejecutar si condicion1 es verdadera\nelif condicion2:\n    # c\u00f3digo a ejecutar si condicion1 es falsa y condicion2 es verdadera\nelse:\n    # c\u00f3digo a ejecutar si ninguna de las condiciones anteriores es verdadera\n\n</code></pre> <p>Por ejemplo, en un condicional if en Python, el bloque de c\u00f3digo indentado despu\u00e9s de la expresi\u00f3n booleana se ejecutar\u00e1 si la expresi\u00f3n es verdadera. Si la expresi\u00f3n es falsa, el bloque de c\u00f3digo se omitir\u00e1 y se continuar\u00e1 ejecutando el c\u00f3digo despu\u00e9s del bloque <code>if</code></p> <p>Aqu\u00ed hay un ejemplo de una expresi\u00f3n booleana simple que utiliza un operador de comparaci\u00f3n y un condicional if.</p> <pre><code>\nnumero = 5\n\nif numero &gt; 0:\n    print(\"El n\u00famero es positivo\")\nelse:\n    print(\"El n\u00famero es negativo o cero\")\n</code></pre> <p>En este ejemplo, la expresi\u00f3n booleana numero &gt; 0 se eval\u00faa como verdadera ya que el valor de la variable numero es mayor que cero. Por lo tanto, se ejecutar\u00e1 el primer bloque de c\u00f3digo y se imprimir\u00e1 \"El n\u00famero es positivo\".</p>"},{"location":"theory/datastructures/","title":"Datastructures","text":""},{"location":"theory/datastructures/#estructuras-de-datos","title":"Estructuras de datos :","text":"<p>Una colecci\u00f3n nos permite agrupar varios objetos bajo un mismo nombre. Por ejemplo, si necesitamos almacenar en nuestro programa los nombres de los alumnos de un curso de programaci\u00f3n, ser\u00e1 m\u00e1s conveniente ubicarlos a todos dentro de una misma colecci\u00f3n de nombre alumnos, en lugar de crear los objetos alumno1, alumno2, etc.</p> <p>En Python existen tres colecciones b\u00e1sicas, a saber: las listas, las tuplas y los diccionarios'</p>"},{"location":"theory/datastructures/#listas","title":"Listas :","text":"<p>Una lista es un conjunto ordenado de objetos. Por objetos entendemos cualquiera de los tipos de dato ya mencionados, incluso otras listas.</p> <p>Para crear una lista, especificamos sus elementos entre corchetes y separados por comas.</p> <pre><code>list_lenguajes = [\"Python\", \"Java\", \"C\", \"C++\"]\n</code></pre>"},{"location":"theory/datastructures/#tuplas","title":"Tuplas :","text":"<p>Las tuplas, al igual que las listas, son colecciones ordenadas. No obstante, a diferencia de \u00e9stas, son inmutables. Es decir, una vez asignados los elementos, no pueden ser alterados. En t\u00e9rminos funcionales, podr\u00eda decirse que las tuplas son un subconjunto de las listas, por cuanto soportan las operaciones con \u00edndices para acceder a sus elementos, pero no as\u00ed las de asignaci\u00f3n.</p> <pre><code>tuples_lenguajes = (\"Python\", \"Java\", \"C\", \"C++\")\n</code></pre>"},{"location":"theory/datastructures/#diccionarios","title":"Diccionarios :","text":"<p>Los diccionarios, a diferencia de las listas y las tuplas, son colecciones no ordenadas de objetos. Adem\u00e1s, sus elementos tienen una particularidad: siempre conforman un par clave-valor. Es decir, cuando a\u00f1adimos un valor a un diccionario, se le asigna una clave \u00fanica con la que luego se podr\u00e1 acceder a \u00e9l (pues la posici\u00f3n ya no es un determinante). Para crear un diccionario, indicamos los pares clave-valor separados por comas y estos, a su vez, separados por dos puntos.</p> <pre><code>dict_lenguajes = {\"Python\": 1991, \"C\": 1972, \"Java\": 1996} \n</code></pre>"},{"location":"theory/datastructures/#set","title":"Set :","text":"<p>Un conjunto es una colecci\u00f3n no ordenada de objetos \u00fanicos. Python provee este tipo de datos por defecto al igual que otras colecciones m\u00e1s convencionales como las listas, tuplas y diccionarios. Los conjuntos son ampliamente utilizados en l\u00f3gica y matem\u00e1tica, y desde el lenguaje podemos sacar provecho de sus propiedades para crear c\u00f3digo m\u00e1s eficiente y legible en menos tiempo.</p> <pre><code>set_lenguajes = {\"Python\", \"Java\", \"C\", \"C++\"}\n</code></pre>"},{"location":"theory/enviroments/","title":"Enviroments","text":""},{"location":"theory/enviroments/#entornos-virtuales","title":"Entornos virtuales:","text":"<p>Un entorno virtual en Python es un ambiente aislado que permite la instalaci\u00f3n y uso de paquetes y versiones espec\u00edficas de Python sin interferir con otras instalaciones de Python y sus paquetes.</p> <p>Los entornos virtuales son \u00fatiles para proyectos en los que se requiere utilizar diferentes versiones de paquetes o para evitar conflictos entre versiones de paquetes en diferentes proyectos.</p> <p>Para crear un entorno virtual en Python, se utiliza la herramienta venv (disponible en Python 3.x) que viene incluida con la instalaci\u00f3n de Python. El comando venv crea una carpeta que contiene todo lo necesario para el entorno virtual, incluyendo una copia del int\u00e9rprete de Python y los paquetes necesarios.</p> <p>Aqu\u00ed te muestro los pasos para crear y utilizar un entorno virtual en Python:</p> <p>1) Abre una terminal o l\u00ednea de comandos y navega a la carpeta donde deseas crear el entorno virtual. 2) Crea el entorno virtual utilizando el siguiente comando.</p> <pre><code>python -m venv nombre_del_entorno_virtual\n</code></pre> <p>Donde nombre_del_entorno_virtual es el nombre que deseas asignar al entorno virtual.</p> <p>3) Activa el entorno virtual con el siguiente comando:</p> <ul> <li>En Windows:</li> </ul> <pre><code>  nombre_del_entorno_virtual\\Scripts\\activate.bat\n</code></pre> <ul> <li>En Linux/Mac:   <code>bash   source nombre_del_entorno_virtual/bin/activate</code></li> </ul> <p>1) Una vez activado el entorno virtual, cualquier paquete que se instale utilizando pip se instalar\u00e1 solo en ese entorno virtual, y no interferir\u00e1 con otros entornos virtuales o instalaciones de Python. 2) Para desactivar el entorno virtual, simplemente utiliza el comando deactivate.</p> <p>En resumen, los entornos virtuales en Python son ambientes aislados que permiten la instalaci\u00f3n y uso de paquetes y versiones espec\u00edficas de Python sin interferir con otras instalaciones de Python y sus paquetes. Se crean utilizando la herramienta venv y se activan y desactivan utilizando comandos espec\u00edficos en la l\u00ednea de comandos.</p> <p>En Python existen varias herramientas para administrar paquetes y dependencias de proyectos:</p>"},{"location":"theory/enviroments/#administradoras-de-paquetes-python","title":"Administradoras de paquetes python:","text":"<p>1) pip: Es el administrador de paquetes est\u00e1ndar para Python. Se utiliza para instalar y desinstalar paquetes, y tambi\u00e9n para actualizarlos. Pip permite la instalaci\u00f3n de paquetes desde repositorios p\u00fablicos o privados y tambi\u00e9n permite la instalaci\u00f3n de paquetes desde archivos de distribuci\u00f3n.</p> <p>2) conda: Es un administrador de paquetes y entornos virtuales que se enfoca en el an\u00e1lisis de datos, la ciencia y el aprendizaje autom\u00e1tico. Conda permite la creaci\u00f3n de entornos virtuales con paquetes espec\u00edficos y la instalaci\u00f3n de paquetes desde diferentes fuentes.</p> <p>3) PyPI: Es el repositorio oficial de paquetes de Python. Se puede acceder a trav\u00e9s de la herramienta pip para instalar paquetes directamente desde el repositorio. PyPI es un repositorio p\u00fablico, por lo que cualquier persona puede publicar un paquete.</p> <p>4) Anaconda: Es una distribuci\u00f3n de Python que incluye un conjunto de paquetes comunes utilizados en el an\u00e1lisis de datos, la ciencia y el aprendizaje autom\u00e1tico. Adem\u00e1s de los paquetes, Anaconda tambi\u00e9n incluye la herramienta conda para la gesti\u00f3n de paquetes y entornos virtuales.</p> <p>5) pipenv: Es una herramienta de administraci\u00f3n de dependencias que combina pip y virtualenv. Pipenv se utiliza para crear y administrar entornos virtuales y para manejar las dependencias del proyecto. Pipenv tambi\u00e9n gestiona la seguridad de las dependencias y asegura que las versiones de los paquetes sean compatibles.</p>"},{"location":"theory/exceptions/","title":"Exceptions","text":""},{"location":"theory/exceptions/#excepciones","title":"excepciones:","text":"<p>En Python, las excepciones son errores que ocurren durante la ejecuci\u00f3n de un programa. Cuando se produce una excepci\u00f3n, el programa se detiene y se muestra un mensaje de error que indica el tipo de excepci\u00f3n y la l\u00ednea de c\u00f3digo en la que ocurri\u00f3.'</p> <p>Las excepciones se manejan en Python utilizando la estructura try-except. La sintaxis b\u00e1sica es la siguiente:</p> <pre><code>try:\n    # C\u00f3digo que puede causar una excepci\u00f3n\nexcept ExceptionType:\n    # C\u00f3digo que se ejecutar\u00e1 si se produce una excepci\u00f3n del tipo ExceptionType\n</code></pre> <p>En la estructura try-except, el c\u00f3digo que puede causar una excepci\u00f3n se coloca dentro del bloque try, mientras que el c\u00f3digo que se ejecutar\u00e1 si se produce una excepci\u00f3n se coloca dentro del bloque except. La excepci\u00f3n se especifica como un tipo de excepci\u00f3n en la cl\u00e1usula except. Si se produce una excepci\u00f3n del tipo especificado, se ejecutar\u00e1 el bloque except.</p> <pre><code>try:\n    resultado = 10 / 0\nexcept ZeroDivisionError:\n    print(\"No se puede dividir entre cero\")\n</code></pre> <p>el c\u00f3digo dentro del bloque try intenta dividir 10 por cero, lo que resulta en una excepci\u00f3n ZeroDivisionError.</p>"},{"location":"theory/frameworks/","title":"Frameworks","text":""},{"location":"theory/frameworks/#frameworks","title":"Frameworks:","text":"<p>Un framework es una estructura o conjunto de herramientas que proporciona una forma predefinida de construir y desarrollar aplicaciones. Los frameworks se utilizan para simplificar y acelerar el proceso de desarrollo, proporcionando una estructura s\u00f3lida y consistente para la aplicaci\u00f3n.</p> <p>En general, un framework funciona proporcionando una estructura base de c\u00f3digo que incluye una serie de componentes y bibliotecas comunes que se utilizan para construir la aplicaci\u00f3n. Estos componentes incluyen, por ejemplo, la gesti\u00f3n de la base de datos, el manejo de las solicitudes HTTP, el manejo de los formularios y la validaci\u00f3n de datos, entre otros.</p> <p>Al utilizar un framework, el desarrollador puede centrarse en la l\u00f3gica espec\u00edfica de la aplicaci\u00f3n y no en las tareas comunes y repetitivas que pueden ser manejadas por el framework. Adem\u00e1s, el framework tambi\u00e9n proporciona una serie de convenciones y pr\u00e1cticas recomendadas que ayudan a garantizar que la aplicaci\u00f3n se construya de manera consistente y siguiendo las mejores pr\u00e1cticas.</p> <p>En resumen, los frameworks son una herramienta poderosa para simplificar y acelerar el proceso de desarrollo de aplicaciones al proporcionar una estructura s\u00f3lida y consistente para la construcci\u00f3n de la aplicaci\u00f3n y permitir que el desarrollador se centre en la l\u00f3gica espec\u00edfica de la aplicaci\u00f3n.</p>"},{"location":"theory/frameworks/#django","title":"Django:","text":"<p>Django es un framework de desarrollo web de alto nivel en Python que se basa en el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC). El objetivo principal de Django es permitir que los desarrolladores web construyan aplicaciones de manera r\u00e1pida y sencilla, sin tener que preocuparse por la complejidad subyacente de la infraestructura web.</p> <p>Django utiliza una arquitectura de \"bater\u00edas incluidas\", lo que significa que viene con muchas caracter\u00edsticas integradas, como un ORM (Object-Relational Mapping) para interactuar con la base de datos, un enrutador de URL, un sistema de plantillas y un sistema de autenticaci\u00f3n, entre otras.</p> <p>En general, el proceso de construcci\u00f3n de una aplicaci\u00f3n web en Django implica los siguientes pasos:</p> <p>1) Definir el modelo de datos: esto implica definir las tablas de la base de datos, incluyendo los campos y las relaciones entre ellas.</p> <p>2) Crear vistas: las vistas son las funciones que procesan las solicitudes del usuario y producen una respuesta. En Django, las vistas se definen en un archivo de vistas.py.</p> <p>4) Configurar URL: se utiliza un archivo urls.py para definir c\u00f3mo se deben mapear las URLs a las vistas correspondientes.</p> <p>5) Crear plantillas: las plantillas se utilizan para generar la salida HTML que se enviar\u00e1 al navegador del usuario.</p> <p>6) Desplegar la aplicaci\u00f3n: finalmente, la aplicaci\u00f3n se puede desplegar en un servidor web.</p> <p>Django es altamente personalizable y escalable, lo que lo hace adecuado para una amplia variedad de aplicaciones web, desde sitios web peque\u00f1os y simples hasta aplicaciones web empresariales complejas. Tambi\u00e9n cuenta con una gran comunidad de desarrolladores y una amplia documentaci\u00f3n que facilita el aprendizaje y el desarrollo de aplicaciones en Django.</p>"},{"location":"theory/functions/","title":"Functions","text":""},{"location":"theory/functions/#funciones","title":"Funciones:","text":"<p>En Python, las funciones son bloques de c\u00f3digo que realizan una tarea espec\u00edfica y pueden ser llamados desde otras partes del c\u00f3digo. Las funciones en Python se definen utilizando la palabra clave def seguida del nombre de la funci\u00f3n y los par\u00e1metros que acepta entre par\u00e9ntesis. La sintaxis b\u00e1sica para definir una funci\u00f3n es la siguiente:</p> <pre><code>def nombre_funcion(parametro1, parametro2, ...):\n    # C\u00f3digo que realiza la tarea de la funci\u00f3n\n    return resultado\n</code></pre> <p>Dentro de la funci\u00f3n se puede incluir cualquier c\u00f3digo v\u00e1lido en Python, como operaciones matem\u00e1ticas, operaciones de comparaci\u00f3n, bucles, condicionales y llamadas a otras funciones. La funci\u00f3n puede tener cero o m\u00e1s par\u00e1metros, que son valores que se pasan a la funci\u00f3n cuando se llama.</p> <p>Cuando se llama a una funci\u00f3n en Python, se escribe el nombre de la funci\u00f3n seguido de los argumentos entre par\u00e9ntesis. Los argumentos se pasan a la funci\u00f3n en el mismo orden en que se definen los par\u00e1metros.</p> <p>La funci\u00f3n puede devolver un valor utilizando la palabra clave return. El valor devuelto por la funci\u00f3n puede ser cualquier objeto v\u00e1lido en Python, como un n\u00famero, una cadena de texto, una lista o un diccionario.</p> <pre><code>def suma(a, b):\n    resultado = a + b\n    return resultado\n\nresultado_suma = suma(5, 7)\nprint(resultado_suma)\n</code></pre> <p>las funciones en Python pueden ser muy \u00fatiles para dividir un programa en piezas m\u00e1s peque\u00f1as y reutilizables, lo que hace que el c\u00f3digo sea m\u00e1s f\u00e1cil de mantener y entender.</p>"},{"location":"theory/github/","title":"Github","text":""},{"location":"theory/github/#github","title":"Github:","text":"<p>GitHub es una plataforma web para alojar y gestionar proyectos de software utilizando el sistema de control de versiones Git. GitHub permite a los desarrolladores trabajar en equipo, compartir su c\u00f3digo y colaborar en proyectos de software de manera efectiva.</p> <p>El proceso b\u00e1sico de trabajo en GitHub es el siguiente:</p> <ol> <li> <p>Crear una cuenta de usuario en GitHub.</p> </li> <li> <p>Crear un nuevo repositorio de Git en GitHub.</p> </li> <li> <p>Clonar el repositorio en una m\u00e1quina local.</p> </li> <li> <p>A\u00f1adir, editar o eliminar archivos en la copia local del repositorio.</p> </li> <li> <p>Hacer un commit de los cambios en la rama local.</p> </li> <li> <p>Hacer un push de la rama local al repositorio remoto en GitHub.</p> </li> <li> <p>Crear una pull request para solicitar que los cambios se integren en la rama principal del repositorio.</p> </li> <li> <p>Revisar y discutir los cambios con otros colaboradores.</p> </li> <li> <p>Fusionar la pull request en la rama principal del repositorio si los cambios son aceptados.</p> </li> </ol> <p>Adem\u00e1s de alojar y gestionar proyectos de software, GitHub tambi\u00e9n ofrece una serie de herramientas y servicios adicionales, como seguimiento de problemas, solicitudes de funciones, integraci\u00f3n continua y despliegue autom\u00e1tico.</p>"},{"location":"theory/github/#comandos-basicos","title":"Comandos b\u00e1sicos:","text":"<pre><code>git add .: Agrega todos los cambios realizados en el directorio actual para ser incluidos en el pr\u00f3ximo commit.\ngit commit -m \u201ccomentario\u201d: Crea un nuevo commit con los cambios agregados con git add y con el comentario proporcionado.\ngit push &lt;nombre del origen remoto&gt; &lt;nombre de rama remota&gt;: Sube los cambios al repositorio remoto.\n</code></pre>"},{"location":"theory/github/#comandos-para-trabajar-con-ramas","title":"Comandos para trabajar con ramas:","text":"<pre><code>git status: Muestra el estado actual del repositorio, incluyendo la rama actual.\ngit checkout &lt;nombre de la rama&gt;: Cambia a la rama especificada.\ngit checkout -b &lt;nombre de la rama&gt;: Crea una nueva rama y cambia a ella.\ngit branch &lt;nombre de la rama&gt;: Crea una nueva rama.\ngit branch --list: Lista todas las ramas en el repositorio local.\ngit branch -d &lt;nombre de la rama&gt;: Borra la rama especificada.\ngit pull: Actualiza la rama actual con los cambios del repositorio remoto.\ngit merge &lt;nombre de la rama&gt;: Fusiona la rama especificada con la rama actual.\n</code></pre>"},{"location":"theory/github/#comando-para-deshacer-cambios","title":"Comando para deshacer cambios:","text":"<pre><code>git revert &lt;c\u00f3digo del commit&gt;: Crea un nuevo commit que deshace los cambios realizados en el commit especificado.\n</code></pre> <p>Comandos para guardar cambios temporalmente:</p> <pre><code>git stash save \"nombre del stash\": Guarda temporalmente los cambios que a\u00fan no se han confirmado.\ngit stash list: Muestra la lista de todos los stashes guardados.\ngit checkout &lt;nombre de la rama&gt;: Cambia a otra rama.\ngit stash apply: Aplica los cambios guardados en el \u00faltimo stash.\n</code></pre>"},{"location":"theory/github/#documento-recomendado","title":"Documento recomendado \ud83d\udcd3","text":"<p>Cheatsheet</p>"},{"location":"theory/lambdas/","title":"Lambdas","text":""},{"location":"theory/lambdas/#lambdas","title":"Lambdas:","text":"<p>una funci\u00f3n lambda es una funci\u00f3n an\u00f3nima que se define sin necesidad de utilizar la palabra clave def. En lugar de eso, se utiliza la palabra clave lambda seguida de los par\u00e1metros de la funci\u00f3n y una expresi\u00f3n que define lo que hace la funci\u00f3n.</p> <p>La sintaxis b\u00e1sica para definir una funci\u00f3n lambda en Python es la siguiente:</p> <pre><code>lambda argumentos: expresion\n\n</code></pre> <p>Por ejemplo, una funci\u00f3n lambda que devuelve el doble de su argumento se podr\u00eda definir as\u00ed:</p> <pre><code>doble = lambda x: x * 2\n\n</code></pre> <p>En este ejemplo, lambda x: define la funci\u00f3n lambda, que toma un argumento x, y x * 2 es la expresi\u00f3n que devuelve el doble de x. La funci\u00f3n lambda se asigna a la variable doble, que puede ser llamada como cualquier otra funci\u00f3n.</p> <p>Las funciones lambda se utilizan a menudo para definir funciones simples que s\u00f3lo se utilizan en un lugar del c\u00f3digo y no necesitan un nombre propio. Tambi\u00e9n son muy \u00fatiles para definir funciones que se pasan como argumentos a otras funciones, como las funciones map() o filter().</p> <pre><code>numeros = [1, 2, 3, 4, 5]\ndobles = list(map(lambda x: x * 2, numeros))\nprint(dobles)\n\n</code></pre> <p>En este ejemplo, se define una lista llamada numeros que contiene algunos n\u00fameros enteros. Luego, se utiliza la funci\u00f3n map() para aplicar una funci\u00f3n lambda que multiplica cada n\u00famero por dos a cada elemento de la lista.</p>"},{"location":"theory/loops/","title":"Loops","text":""},{"location":"theory/loops/#bucles","title":"Bucles:","text":""},{"location":"theory/loops/#bucle-for","title":"Bucle for:","text":"<p>El for en Python es una estructura de control de flujo que se utiliza para iterar sobre una secuencia de elementos (por ejemplo, una lista, una tupla, un diccionario, etc.) y realizar una operaci\u00f3n en cada elemento de la secuencia. La sintaxis b\u00e1sica de un bucle for en Python es la siguiente:</p> <pre><code>for variable in secuencia:\n    # cuerpo del bucle\n</code></pre> <p>La variable toma el valor de cada elemento de la secuencia en cada iteraci\u00f3n del bucle, y el cuerpo del bucle (las instrucciones que se encuentran indentadas debajo del encabezado del bucle for) se ejecutan una vez para cada elemento de la secuencia.</p> <p>Por ejemplo, si quisieras imprimir cada elemento de una lista, podr\u00edas hacerlo con un bucle for de la siguiente manera:</p> <pre><code>lista = [1, 2, 3, 4, 5]\nfor elemento in lista:\n    print(elemento)\n</code></pre> <p>Esto imprimir\u00e1 cada elemento de la lista en una l\u00ednea separada.</p> <p>Tambi\u00e9n puedes utilizar la funci\u00f3n range() para generar una secuencia de n\u00fameros en un rango determinado, como en el siguiente ejemplo:</p> <pre><code>for i in range(1, 6):\n    print(i)\n</code></pre> <p>Esto imprimir\u00e1 los n\u00fameros del 1 al 5 en l\u00edneas separadas.</p>"},{"location":"theory/loops/#cuando-usarlo","title":"Cuando usarlo?","text":"<p>Se utiliza cuando se conoce el n\u00famero exacto de iteraciones que se deben realizar. El bucle \"for\" itera sobre una secuencia (como una lista, una cadena de caracteres o una tupla) y ejecuta el bloque de c\u00f3digo correspondiente para cada elemento de la secuencia.</p>"},{"location":"theory/loops/#bucle-while","title":"Bucle while:","text":"<p>En Python, el bucle while se utiliza para ejecutar un bloque de c\u00f3digo repetidamente mientras se cumpla una determinada condici\u00f3n. El bucle while sigue ejecutando el bloque de c\u00f3digo mientras la condici\u00f3n especificada sea verdadera.</p> <p>La sintaxis b\u00e1sica del bucle while en Python es la siguiente:</p> <pre><code>while condici\u00f3n:\n    # C\u00f3digo a ejecutar mientras se cumpla la condici\u00f3n\n</code></pre> <p>La condici\u00f3n es una expresi\u00f3n booleana que se eval\u00faa antes de cada iteraci\u00f3n del bucle. Si la condici\u00f3n es verdadera, el c\u00f3digo dentro del bucle se ejecuta. Si la condici\u00f3n es falsa, el bucle se detiene y la ejecuci\u00f3n contin\u00faa despu\u00e9s del bucle.</p> <p>Es importante tener en cuenta que si la condici\u00f3n nunca se vuelve falsa, el bucle while continuar\u00e1 ejecut\u00e1ndose indefinidamente, lo que se conoce como un \"bucle infinito\". Para evitar esto, se debe asegurar que en alg\u00fan momento la condici\u00f3n se vuelva falsa.</p> <p>Algunos ejemplos de uso del bucle while en Python son:</p> <ul> <li>Realizar un c\u00e1lculo iterativo hasta que se alcance una cierta precisi\u00f3n.</li> <li>Leer datos de entrada del usuario hasta que se ingrese una entrada v\u00e1lida.</li> <li>Procesar una lista de elementos mientras se cumpla cierta condici\u00f3n.</li> <li>Realizar una tarea de manera repetitiva hasta que se cumpla cierta condici\u00f3n.</li> </ul> <p>Un bucle while se utiliza en Python cuando se desea ejecutar un bloque de c\u00f3digo repetidamente mientras se cumpla una condici\u00f3n determinada.</p> <pre><code>numero = -1\nwhile numero &lt; 0:\n    entrada = input(\"Ingrese un n\u00famero entero positivo: \")\n    if entrada.isdigit():\n        numero = int(entrada)\n    else:\n        print(\"Entrada no v\u00e1lida. Intente de nuevo.\")\nprint(\"El n\u00famero ingresado es:\", numero)\n\n</code></pre> <p>En este ejemplo, el bucle while sigue pidiendo la entrada del usuario hasta que se ingresa un n\u00famero entero positivo. En cada iteraci\u00f3n, se verifica si la entrada es un n\u00famero entero positivo utilizando el m\u00e9todo isdigit() de la cadena de texto ingresada. Si es as\u00ed, se convierte a entero y se almacena en la variable numero. Si no es un n\u00famero v\u00e1lido, se muestra un mensaje de error y se solicita al usuario que ingrese nuevamente. Una vez que se ha ingresado un n\u00famero v\u00e1lido, el bucle while se detiene y se imprime el valor ingresado.</p>"},{"location":"theory/modules/","title":"Modules","text":""},{"location":"theory/modules/#modulos","title":"Modulos:","text":"<p>En Python, un m\u00f3dulo es un archivo con extensi\u00f3n .py que contiene c\u00f3digo Python. Los m\u00f3dulos se utilizan para organizar y reutilizar el c\u00f3digo, permitiendo la separaci\u00f3n de las funcionalidades en diferentes archivos.</p> <p>Para utilizar un m\u00f3dulo en un programa Python, es necesario importarlo en el c\u00f3digo. Esto se puede hacer con la instrucci\u00f3n import seguida del nombre del m\u00f3dulo. Tambi\u00e9n se puede utilizar la instrucci\u00f3n from seguida del nombre del m\u00f3dulo y la palabra clave import para importar funciones o clases espec\u00edficas del m\u00f3dulo.</p> <p>Una vez que se ha importado un m\u00f3dulo, se pueden utilizar sus funciones, clases y variables en el programa actual. Para acceder a los elementos del m\u00f3dulo, se utiliza la sintaxis nombre_del_modulo.elemento. Por ejemplo, si se ha importado el m\u00f3dulo math y se quiere utilizar la funci\u00f3n sin, se puede llamar a math.sin().</p> <p>Adem\u00e1s de los m\u00f3dulos predefinidos que vienen con Python, es posible crear y utilizar m\u00f3dulos personalizados en los proyectos. Para hacer esto, simplemente se debe crear un archivo .py con el nombre del m\u00f3dulo y definir las funciones y clases necesarias en el archivo.</p> <p>En resumen, los m\u00f3dulos en Python son archivos .py que contienen c\u00f3digo Python que se utiliza para organizar y reutilizar el c\u00f3digo. Se pueden importar en un programa con la instrucci\u00f3n import y se accede a sus elementos utilizando la sintaxis nombre_del_modulo.elemento. Los m\u00f3dulos personalizados tambi\u00e9n se pueden crear y utilizar en los proyectos.</p> <p>Supongamos que tenemos un programa que necesita utilizar la funci\u00f3n sqrt del m\u00f3dulo math para calcular la ra\u00edz cuadrada de un n\u00famero. En este caso, podemos importar el m\u00f3dulo math en nuestro programa de la siguiente manera:</p> <pre><code>import math\n\nx = 16\nraiz_cuadrada = math.sqrt(x)\nprint(raiz_cuadrada)\n</code></pre>"},{"location":"theory/operators/","title":"Operators","text":""},{"location":"theory/operators/#operadores","title":"Operadores:","text":"<p>Los operadores son s\u00edmbolos que se utilizan para realizar operaciones en Python. Algunos de los operadores m\u00e1s comunes en Python son:</p> <p>1) Operadores aritm\u00e9ticos:</p> <pre><code>- Suma (+)\n\n- Resta (-)\n\n- Multiplicaci\u00f3n (*)\n\n- Divisi\u00f3n (/)\n\n- Divisi\u00f3n entera (//)\n\n- M\u00f3dulo (%)\n\n- Potencia (**)\n</code></pre> <p>2) Operadores de comparaci\u00f3n:</p> <pre><code>-Igual que (==)\n\n-Distinto de (!=)\n\n-Mayor que (&gt;)\n\n-Menor que (&lt;)\n\n-Mayor o igual que (&gt;=)\n\n-Menor o igual que (&lt;=)\n\n-Operadores l\u00f3gicos:\n\n-And (and)\n\n-Or (or)\n\n-Not (not)\n</code></pre> <p>3) Operadores de asignaci\u00f3n:</p> <pre><code>-Asignaci\u00f3n (=)\n\n-Asignaci\u00f3n aumentada (+=, -=, *=, /=, %=, //=, **=)\n</code></pre> <p>4) Operadores de pertenencia:</p> <pre><code>-Pertenencia en lista (in)\n\n-No pertenencia en lista (not in)\n</code></pre> <p>5) Operadores de identidad:</p> <pre><code>-Identidad (is)\n\n-No identidad (is not)\n</code></pre> <p>Es importante conocer los diferentes operadores en Python para poder utilizarlos en las operaciones y expresiones de nuestros programas.</p>"},{"location":"theory/poo/","title":"Poo","text":""},{"location":"theory/poo/#poo","title":"POO:","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se enfoca en la creaci\u00f3n de objetos que interact\u00faan entre s\u00ed para resolver un problema. En la POO, un objeto es una instancia de una clase, que es una plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos) de los objetos que se crean a partir de ella.</p> <p>La POO se basa en cuatro conceptos fundamentales: encapsulamiento, abstracci\u00f3n, herencia y polimorfismo.</p>"},{"location":"theory/poo/#encapsulamiento","title":"Encapsulamiento:","text":"<p>Es el proceso de ocultar la complejidad del c\u00f3digo interno de un objeto, y exponer solo las funciones y datos necesarios para interactuar con ese objeto. Esto se logra mediante el uso de atributos y m\u00e9todos p\u00fablicos y privados. Los atributos p\u00fablicos son aquellos que pueden ser accedidos desde fuera del objeto, mientras que los privados solo pueden ser accedidos desde dentro del objeto. Los m\u00e9todos p\u00fablicos son aquellos que pueden ser llamados desde fuera del objeto, mientras que los m\u00e9todos privados solo pueden ser llamados desde dentro del objeto.</p>"},{"location":"theory/poo/#abstraccion","title":"Abstracci\u00f3n:","text":"<p>La abstracci\u00f3n es un concepto importante en la programaci\u00f3n orientada a objetos que consiste en simplificar la complejidad de un objeto al exponer solo lo necesario para resolver un problema. Se logra mediante el uso de interfaces y clases abstractas que definen un comportamiento com\u00fan para varios objetos diferentes y permiten crear una jerarqu\u00eda de clases que comparten un comportamiento com\u00fan. La abstracci\u00f3n facilita el desarrollo de aplicaciones complejas y reduce la probabilidad de errores en el c\u00f3digo.</p>"},{"location":"theory/poo/#herencia","title":"Herencia:","text":"<p>La herencia es un mecanismo de la POO que permite la creaci\u00f3n de una nueva clase (subclase) a partir de una clase existente (superclase). La subclase hereda todas las propiedades y comportamientos de la superclase, y puede a\u00f1adir o modificar sus propios atributos y m\u00e9todos. De esta manera, se puede reutilizar c\u00f3digo y definir jerarqu\u00edas de clases que compartan comportamientos y atributos comunes. La subclase puede utilizar los m\u00e9todos y atributos de la superclase, y tambi\u00e9n puede definir sus propios m\u00e9todos y atributos para ampliar o modificar el comportamiento de la superclase seg\u00fan sea necesario.</p>"},{"location":"theory/poo/#polimorfismo","title":"Polimorfismo:","text":"<p>El polimorfismo es la capacidad de un objeto de tomar diferentes formas o comportamientos seg\u00fan el contexto. En la POO, esto se logra al utilizar una subclase en lugar de una superclase, y esperar que tenga un comportamiento similar. Esto se puede hacer mediante la sobrescritura de un m\u00e9todo en la subclase con una implementaci\u00f3n diferente a la de la superclase, o mediante la sobrecarga de un m\u00e9todo en la subclase con diferentes argumentos o tipos de retorno.</p>"},{"location":"theory/poo/#resumen","title":"Resumen:","text":"<p>En Python, todo es un objeto, desde una lista hasta una funci\u00f3n. Para crear una clase en Python, se utiliza la palabra clave class, seguida del nombre de la clase y dos puntos. Los atributos y m\u00e9todos se definen dentro de la clase, y se acceden mediante la sintaxis objeto.atributo o objeto.metodo(). Para crear un objeto de una clase, se utiliza la sintaxis objeto = Clase(), donde Clase es el nombre de la clase.</p>"},{"location":"theory/python/","title":"Python","text":""},{"location":"theory/python/#que-es-python","title":"Que es python?","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado, din\u00e1mico y de alto nivel. Fue creado por Guido van Rossum en 1991 y se ha convertido en uno de los lenguajes de programaci\u00f3n m\u00e1s populares y utilizados en todo el mundo.</p>"},{"location":"theory/python/#por-que-python","title":"Por que Python?","text":"<ul> <li> <p>Sintaxis clara y legible: Python tiene una sintaxis muy sencilla y f\u00e1cil de leer, lo que facilita la comprensi\u00f3n del c\u00f3digo. Esto hace que sea ideal para los principiantes.</p> </li> <li> <p>Amplia comunidad: Python cuenta con una comunidad muy activa y diversa de desarrolladores, lo que significa que siempre hay una gran cantidad de recursos y herramientas disponibles para ayudar a los programadores.</p> </li> <li> <p>Multiplataforma: Python se puede ejecutar en una amplia variedad de plataformas, incluyendo Windows, Linux, Mac y otros sistemas operativos.</p> </li> <li> <p>Gran cantidad de librer\u00edas y frameworks: Python tiene una gran cantidad de librer\u00edas y frameworks disponibles, lo que permite a los desarrolladores crear aplicaciones de alta calidad en poco tiempo.</p> </li> <li> <p>Alto nivel de abstracci\u00f3n: Python es un lenguaje de programaci\u00f3n de alto nivel que permite a los desarrolladores escribir c\u00f3digo de manera m\u00e1s eficiente y r\u00e1pida, lo que significa que pueden centrarse en la l\u00f3gica de negocio en lugar de en detalles de bajo nivel.</p> </li> <li> <p>Versatilidad: Python es un lenguaje muy vers\u00e1til que se puede utilizar en diferentes \u00e1reas, como el desarrollo web, la ciencia de datos, el an\u00e1lisis de datos, la inteligencia artificial, el aprendizaje autom\u00e1tico, la automatizaci\u00f3n de tareas y muchos otros campos.</p> </li> <li> <p>Gratuito y de c\u00f3digo abierto: Python es un lenguaje de programaci\u00f3n gratuito y de c\u00f3digo abierto, lo que significa que cualquier persona puede descargarlo y utilizarlo sin costo alguno. Adem\u00e1s, el c\u00f3digo fuente est\u00e1 disponible para que los desarrolladores lo puedan modificar y mejorar.</p> </li> </ul>"},{"location":"theory/test/","title":"Test","text":""},{"location":"theory/test/#test","title":"Test:","text":""},{"location":"theory/test/#doctest","title":"Doctest:","text":"<p>Doctest es un m\u00f3dulo de pruebas integrado en Python que permite escribir pruebas en l\u00ednea dentro de la documentaci\u00f3n de un m\u00f3dulo o funci\u00f3n. Las pruebas escritas en la documentaci\u00f3n pueden ser ejecutadas autom\u00e1ticamente utilizando el m\u00f3dulo doctest.</p> <p>El m\u00f3dulo doctest busca las pruebas dentro de la documentaci\u00f3n, las ejecuta y verifica si los resultados coinciden con los valores esperados. Si alguna prueba falla, se muestra un mensaje de error.</p> <p>Para escribir pruebas en l\u00ednea con doctest, se utilizan las siguientes convenciones:</p> <ul> <li> <p>Las pruebas se escriben en la documentaci\u00f3n despu\u00e9s de los docstrings y antes de la definici\u00f3n de la funci\u00f3n o m\u00e9todo.</p> </li> <li> <p>Las pruebas se escriben como una sesi\u00f3n interactiva de Python, incluyendo la entrada y la salida esperada.</p> </li> <li> <p>La entrada y la salida esperada se escriben como cadenas de texto y se utilizan los caracteres \"&gt;&gt;&gt;\" para indicar la entrada y \"...\" para indicar la salida esperada.</p> </li> </ul> <p>Un ejemplo de pruebas escritas con doctest se ver\u00eda as\u00ed:</p> <pre><code>def suma(a, b):\n    \"\"\"\n    Suma dos n\u00fameros y devuelve el resultado.\n\n    &gt;&gt;&gt; suma(2, 3)\n    5\n    &gt;&gt;&gt; suma(0, 0)\n    0\n    &gt;&gt;&gt; suma(-1, 1)\n    0\n    \"\"\"\n    return a + b\n</code></pre> <p>En este ejemplo, se han escrito tres pruebas para la funci\u00f3n suma utilizando doctest. Cada prueba se escribe como una sesi\u00f3n interactiva de Python, indicando la entrada y la salida esperada. Para ejecutar las pruebas, se utiliza el siguiente c\u00f3digo:</p> <pre><code>import doctest\n\ndoctest.testmod()\n</code></pre> <p>El m\u00e9todo testmod() busca todas las pruebas dentro de los docstrings del m\u00f3dulo actual y las ejecuta autom\u00e1ticamente. Si todas las pruebas pasan, no se mostrar\u00e1 ning\u00fan mensaje. Si alguna prueba falla, se mostrar\u00e1 un mensaje de error.</p> <p>Doctest es una forma sencilla y eficaz de escribir y ejecutar pruebas dentro de la documentaci\u00f3n de un m\u00f3dulo o funci\u00f3n en Python.</p>"},{"location":"theory/test/#pytest","title":"Pytest:","text":"<p>Pytest es un marco de pruebas de software en Python que permite escribir y ejecutar pruebas de manera f\u00e1cil y eficiente. Pytest puede ser utilizado para cualquier tipo de prueba de software, desde pruebas unitarias hasta pruebas de integraci\u00f3n y pruebas de extremo a extremo.</p> <p>Para escribir pruebas con pytest, se definen funciones de prueba que utilizan afirmaciones para verificar si el comportamiento de la funci\u00f3n o m\u00f3dulo probado es correcto. Por ejemplo, una funci\u00f3n de prueba podr\u00eda verificar que la salida de una funci\u00f3n dada es la esperada utilizando una afirmaci\u00f3n.</p> <p>Un ejemplo simple de una funci\u00f3n de prueba utilizando pytest se ver\u00eda as\u00ed:</p> <pre><code>\ndef suma(a, b):\n    return a + b\n\n\ndef test_suma():\n    assert suma(2, 3) == 5\n    assert suma(0, 0) == 0\n    assert suma(-1, 1) == 0\n</code></pre> <p>En este ejemplo, se define una funci\u00f3n de prueba llamada test_suma que verifica el comportamiento de la funci\u00f3n suma. Dentro de la funci\u00f3n de prueba, se utilizan afirmaciones para verificar si la salida de la funci\u00f3n es la esperada.</p> <p>Para ejecutar las pruebas con pytest, se utiliza el siguiente comando en la l\u00ednea de comandos:</p> <pre><code>pytest\n</code></pre> <p>Este comando buscar\u00e1 autom\u00e1ticamente todas las funciones de prueba que comiencen con el prefijo <code>\"test_\"</code> y las ejecutar\u00e1. Si todas las pruebas pasan, no se mostrar\u00e1 ning\u00fan mensaje. Si alguna prueba falla, se mostrar\u00e1 un mensaje de error que indica qu\u00e9 prueba fall\u00f3 y por qu\u00e9.</p> <p>Adem\u00e1s de las afirmaciones simples, pytest ofrece una serie de caracter\u00edsticas avanzadas, como parametrizaci\u00f3n de pruebas, marcadores, configuraci\u00f3n personalizada y plugins de terceros. Esto hace que pytest sea una herramienta muy flexible y poderosa para escribir y ejecutar pruebas en Python.</p>"},{"location":"theory/tips/","title":"Tips","text":""},{"location":"theory/tips/#indentacion","title":"Indentacion","text":"<p>En Python, el bloque de c\u00f3digo se delimita mediante la indentaci\u00f3n, es decir, insertando espacios o tabulaciones al inicio de las l\u00edneas que conforman el bloque. Esto es diferente a otros lenguajes de programaci\u00f3n, como Java o C, donde se utilizan llaves para delimitar el bloque. La indentaci\u00f3n es obligatoria en Python y es importante para la estructura y legibilidad del c\u00f3digo.</p> <pre><code>if condicion:\n    # bloque de c\u00f3digo\n    sentencia1\n    sentencia2\n    ...\nelse:\n    # bloque de c\u00f3digo\n    sentencia3\n    sentencia4\n    ...\n</code></pre> <p>Se puede observar que el bloque de c\u00f3digo dentro de la estructura if est\u00e1 indentado hacia la derecha, lo que indica que es parte del mismo bloque y se ejecutar\u00e1 s\u00f3lo si se cumple la condici\u00f3n. El bloque de c\u00f3digo dentro de la estructura else tambi\u00e9n est\u00e1 indentado, pero se encuentra en un bloque de c\u00f3digo diferente, por lo que se ejecutar\u00e1 si no se cumple la condici\u00f3n.</p>"},{"location":"theory/tips/#comentarios-de-varias-lineas","title":"Comentarios de varias l\u00edneas","text":"<p>Para escribir comentarios que ocupan varias l\u00edneas, simplemente escribe cada una de las l\u00edneas anteponiendo el car\u00e1cter #:</p> <pre><code># Este comentario ocupa\n# 2 l\u00edneas\n</code></pre> <p>Tambi\u00e9n puedes escribir un comentario en varias l\u00edneas si lo encierras entre tres comillas simples ''' o dobles \"\"\"</p> <pre><code>a = 2\n'''Este comentario\ntambi\u00e9n ocupa 2 l\u00edneas'''\nprint(a)\n</code></pre>"},{"location":"theory/tips/#docstrings","title":"Docstrings","text":"<p>Los docstrings son un tipo de comentarios especiales que se usan para documentar un m\u00f3dulo, funci\u00f3n, clase o m\u00e9todo. En realidad son la primera sentencia de cada uno de ellos y se encierran entre tres comillas simples o dobles.</p> <pre><code>def suma(a, b):\n    \"\"\"Esta funci\u00f3n devuelve la suma de los par\u00e1metros a y b\"\"\"\n    return a + b\n</code></pre>"},{"location":"theory/tips/#palabras-reservadas-de-python","title":"Palabras reservadas de Python","text":"<p>La lista de palabras reservadas es la siguiente:</p> <pre><code>and, as, assert, break, class, continue, def, del, elif, else, except, False, finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return, True, try, yield, while y with\n</code></pre>"},{"location":"theory/tips/#reglas-y-convencion-de-nombres","title":"Reglas y convenci\u00f3n de nombres :","text":"<p>Algunas reglas y convenciones de nombres para las variables y constantes:  Nunca use s\u00edmbolos especiales como !, @, #, $, %, etc.</p> <p>El primer car\u00e1cter no puede ser un n\u00famero o d\u00edgito.</p> <p>Las constantes son colocadas dentro de m\u00f3dulos Python y significa que no puede ser cambiado.</p> <p>Los nombres de constante y variable deber\u00eda tener la combinaci\u00f3n de letras en min\u00fasculas (de a a la z) o MAY\u00daSCULAS (de la A a la Z) o d\u00edgitos (del 0 al 9) o un underscore (). Por ejemplo:_</p> <pre><code>snake_case\nMACRO_CASE\ncamelCase\nCapWords\n</code></pre> <p>Los nombres que comienzan con gui\u00f3n bajo (simple _ o doble __) se reservan para - variables con significado especial___</p>"},{"location":"theory/types/","title":"Types","text":""},{"location":"theory/types/#tipos-de-datos-en-python","title":"Tipos de datos en Python:","text":"<p>En Python, existen varios tipos de datos que pueden ser utilizados en un programa. Algunos de los tipos de datos m\u00e1s comunes son los siguientes:</p> <ul> <li>Enteros (int): son n\u00fameros enteros positivos o negativos, sin decimales.</li> </ul> <pre><code>numero_entero = 3 \nprint(type(numero_entero)) \n\n&lt;class 'int'&gt; \n</code></pre> <ul> <li>Flotantes (float): son n\u00fameros con decimales.</li> </ul> <pre><code>numero_real = 3.2 \nprint(type(numero_entero)) \n\n&lt;class 'float'&gt; \n</code></pre> <ul> <li>Booleanos (bool): pueden ser True o False, y se utilizan en operaciones l\u00f3gicas.</li> </ul> <pre><code>afirmacion = True \nprint(type(afirmacion)) \n\n&lt;class 'bool'&gt; \n</code></pre> <ul> <li>Cadenas de texto (str): son secuencias de caracteres, y se utilizan para representar texto.</li> </ul> <pre><code>cadena = \"Esto es una string\" \nprint(type(cadena)) \n\n&lt;class 'str'&gt; \n</code></pre> <ul> <li>Listas (list): son secuencias ordenadas de elementos, que pueden ser de diferentes tipos de datos.</li> </ul> <pre><code>lista = [5, \"numero\", \"clavos\"] \nprint(type(lista)) \n\n&lt;class 'list'&gt; \n</code></pre> <ul> <li>Tuplas (tuple): son secuencias ordenadas de elementos, pero a diferencia de las listas, no se pueden modificar.</li> </ul> <pre><code>tupla = (5, \"numero\", \"clavos\") \nprint(type(lista)) \n\n&lt;class 'tuple'&gt; \n</code></pre> <ul> <li>Conjuntos (set): son colecciones desordenadas de elementos \u00fanicos.</li> </ul> <pre><code>set = {1, 2, 3, 4} \nprint(type(set))\n\n&lt;class 'set'&gt; \n</code></pre> <ul> <li>Diccionarios (dict): son colecciones de pares clave-valor, donde cada clave tiene un valor asociado.</li> </ul> <pre><code>diccionario = {\"total\": 55} \nprint(type(diccionario)) \n\n&lt;class 'dict'&gt; \n</code></pre> <p>Estos son los tipos de datos m\u00e1s comunes en Python, pero tambi\u00e9n existen otros tipos, como los bytes y los objetos. Es importante conocer los diferentes tipos de datos para poder utilizarlos de manera efectiva en los programas.</p>"},{"location":"theory/variables/","title":"Variables","text":""},{"location":"theory/variables/#variables","title":"Variables:","text":"<p>Las variables en Python son etiquetas que se utilizan para hacer referencia a los datos almacenados en la memoria. Cuando se crea una variable en Python, se le asigna un nombre que se utiliza para referirse al valor almacenado en ella. En lugar de pensar en una variable como un \"contenedor\" que almacena un valor, es m\u00e1s preciso pensar en ella como una etiqueta que se adhiere a un valor en la memoria.</p> <p>Cada vez que se crea una variable en Python, se asigna un espacio en la memoria para almacenar su valor y su tipo de dato. Es decir, la variable no solo contiene el valor de la informaci\u00f3n, sino que tambi\u00e9n tiene una referencia a su tipo de dato.</p> <p></p> <p>Se puede utilizar el nombre de la variable \"edad\" en el c\u00f3digo para hacer referencia al valor almacenado en ella. Sin embargo, es importante tener en cuenta que, en realidad, lo que se almacena en la variable es una referencia a la ubicaci\u00f3n en la memoria donde se encuentra el valor.</p> <p>Declarar variables individuales:</p> <pre><code>edad = 25\n</code></pre> <p>En este caso, la variable \"edad\" es un objeto de tipo entero que ocupa un espacio en la memoria. Python utiliza la referencia a este objeto para acceder al valor almacenado y manipularlo si es necesario.</p> <p>La raz\u00f3n por la que se considera que las variables son objetos en Python es porque, al igual que los objetos en la programaci\u00f3n orientada a objetos, las variables en Python tienen atributos y m\u00e9todos que pueden ser utilizados para manipular su valor.</p> <p>Por ejemplo, podemos utilizar el m\u00e9todo \"upper()\" en una variable de tipo cadena para convertir todas las letras en may\u00fasculas:</p> <pre><code>nombre = \"juan\"\nnombre_en_mayusculas = nombre.upper()\n</code></pre> <p>En este caso, el m\u00e9todo \"upper()\" se est\u00e1 aplicando a la variable \"nombre\" que es un objeto de tipo cadena y devuelve otra cadena con todas las letras en may\u00fasculas.</p> <p>Varias variables:</p> <pre><code>nombre, apellido, edad = \"Luis\", \"Moralez\", 19\nprint(nombre, apellido, edad)\n\n&gt; \"Luis\", \"Moralez\", 19\n</code></pre> <p>Las variables en Python son locales por defecto. Esto quiere decir que las variables       definidas y utilizadas en el bloque de c\u00f3digo de una funci\u00f3n, s\u00f3lo tienen existencia dentro de la misma, y no interfieren con otras variables del resto del c\u00f3digo.</p> <p>Constantes:</p> <p>En Python, no existe un tipo de dato espec\u00edfico para las constantes, pero convencionalmente se utilizan variables que no se modifican durante la ejecuci\u00f3n del programa para representar valores constantes.</p> <p>Una forma com\u00fan de definir una constante en Python es utilizar una variable en may\u00fasculas para indicar que su valor no debe ser modificado durante la ejecuci\u00f3n del programa.</p> <pre><code>EDAD = 25\n</code></pre> <p>Python define una serie de valores constantes en su propio namespace. Los m\u00e1s importantes son:</p> <p><code>False</code>: El valor false del tipo bool.</p> <p><code>True</code>: El valor true del tipo bool.</p> <p><code>None</code>: El valor del tipo NoneType. Generalmente None se utiliza para representar la ausencia de valor de una variable.</p> <p>Variables globales:</p> <p>En Python, se pueden declarar variables globales para que est\u00e9n disponibles en todo el programa. Una variable global es aquella que se declara fuera de cualquier funci\u00f3n o clase y que se puede acceder desde cualquier parte del c\u00f3digo.</p> <p>Para declarar una variable global en Python, se debe utilizar la palabra clave global seguida del nombre de la variable que se desea declarar como global. Por ejemplo:</p> <pre><code>x = 5  # variable global\n\ndef funcion():\n    global x\n    x = 10  # se modifica la variable global\n\nfuncion()  # llamada a la funci\u00f3n\nprint(x)  # imprime 10\n\n</code></pre>"},{"location":"utilities/algorithm%27s/","title":"Algorithm's","text":""},{"location":"utilities/algorithm%27s/#algoritmos","title":"Algoritmos:","text":"<p>Un algoritmo es un conjunto de instrucciones bien definidas y ordenadas que se utilizan para realizar una tarea espec\u00edfica. En otras palabras, es una serie de pasos l\u00f3gicos que se deben seguir para resolver un problema o realizar una tarea.</p> <p>Por ejemplo, pensemos en un paseo, cuales son nuestros pasos a seguir antes de salir si queremos tener un paseo ideal.</p> <p>Organizamos nuestro viaje:</p> <p>1) Buscamos la mejor ruta para llegar a nuestro destino.    - Investiga y selecciona la mejor opci\u00f3n de transporte, ya sea en autom\u00f3vil, autob\u00fas, tren,     - avi\u00f3n u otro medio de transporte. Aseg\u00farate de conocer las paradas, conexiones y horarios     necesarios para llegar a tu destino.</p> <p>2) Seleccionamos nuestra lista de m\u00fasica favorita.    - Elige tus canciones o playlist favoritos para disfrutar durante el viaje.    - Aseg\u00farate de tener una forma de reproducir la m\u00fasica, ya sea en un reproductor de MP3, tel\u00e9fono m\u00f3vil o en el sistema de audio del veh\u00edculo.</p> <p>3) Elegimos nuestras zapatillas para caminar.    - Elige un par de zapatos c\u00f3modos y adecuados para caminar durante el viaje.    - Considera factores como el clima, la duraci\u00f3n del viaje y el terreno por el que caminar\u00e1s.</p> <p>4) Preparamos nuestro equipaje.</p> <ul> <li>Haz una lista de los art\u00edculos que necesitas llevar contigo durante el viaje.</li> <li>Empaca de manera eficiente y aseg\u00farate de no llevar demasiado equipaje.</li> </ul> <p>5) Verificamos la documentaci\u00f3n necesaria.    - Aseg\u00farate de tener todos los documentos necesarios, como pasaporte, visa, boletos de viaje y cualquier otro documento requerido.    - Verifica las fechas y horarios de tu viaje para evitar retrasos o confusiones.</p> <p>6) Llegamos con anticipaci\u00f3n al punto de partida.    - Aseg\u00farate de llegar con suficiente tiempo de anticipaci\u00f3n para evitar retrasos o apuros.    - Verifica la ubicaci\u00f3n y horarios de salida del medio de transporte que utilizar\u00e1s.</p>"},{"location":"utilities/enviroments/","title":"Enviroments","text":""},{"location":"utilities/enviroments/#python","title":"Python","text":""},{"location":"utilities/enviroments/#que-es-python","title":"\u00bf que es python ?","text":"<p>Es un lenguaje de escritura r\u00e1pido, escalable, robusta y de c\u00f3digo abierto, ventajas que hacen de Python un aliado perfecto para el Pentesting. Permite plasmar ideas complejas con unas pocas l\u00edneas de c\u00f3digo, lo que no es posible con otros lenguajes.</p> <p>Python el 1 de enero del 2020 finalizo oficialmente el soporte a la version 2.7, discontinuaron el software. </p> <pre><code>python                         \nPython 2.7.18 (default, Apr 20 2020, 20:30:41) \n[GCC 9.3.0] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; \n</code></pre> <p>En el sistema kali linux viene por defecto instalado python2 y python3 , pero en este caso python ya no da soporte en python2 , pero kali lo dejo a python2 por el tema que hay muchas herramientas hechas en python.</p> <p>![[Pasted image 20210614222528.png]]</p> <p>Es unos de los lenguajes mas populares en la programacion y que mejor que lo dice google, en este post no vamos a programar en python. Vamos a ver como preparar nuestro entorno para trabajar con Python.</p> <p>con el comando which podemos saber donde tenemos la instalacion de python2</p> <pre><code>which python2                                                                                                                                             \n/bin/python2\n</code></pre> <pre><code>ls -l /usr/bin/python2  \nlrwxrwxrwx root root 9 B Tue Aug  4 04:22:34 2020 \uf481 /usr/bin/python2 \u21d2 python2.7\n</code></pre> <pre><code>ls -l /usr/bin/python2.7\n.rwxr-xr-x root root 3.5 MB Mon Apr 20 16:30:41 2020 \uf016 /usr/bin/python2.7\n</code></pre> <p>Vemos la version de python3 actualizada al dia de la fecha </p> <pre><code>python3\nPython 3.9.2 (default, Feb 28 2021, 17:03:44) \n[GCC 10.2.1 20210110] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; \n\n</code></pre>"},{"location":"utilities/enviroments/#aprendiendo-pip","title":"Aprendiendo pip","text":""},{"location":"utilities/enviroments/#que-es-pip","title":"\u00bf que es pip ?","text":"<p>IP es un acr\u00f3nimo que significa \"Paquetes de instalaci\u00f3n PIP\" o \"Programa de instalaci\u00f3n preferida\". Es una utilidad de l\u00ednea de comandos que le permite instalar, reinstalar o desinstalar paquetes PyPI con un comando simple y directo: \"pip\".</p>"},{"location":"utilities/enviroments/#instalando-python3-pip","title":"Instalando python3-pip","text":"<pre><code>sudo apt install python3-pip\n</code></pre> <p>Les dejo un link donde pueden buscar las librerias de pip </p> <p>https://pypi.org/project/pip/</p>"},{"location":"utilities/enviroments/#el-entorno-de-zsh","title":"El entorno de zsh","text":"<p>ZSH, tambi\u00e9n llamado Z shell, es una versi\u00f3n extendida de Bourne Shell (sh), con muchas caracter\u00edsticas nuevas y soporte para plugins y temas. Dado que se basa en el mismo shell que Bash, ZSH tiene muchas de las mismas caracter\u00edsticas. Empezar a utilizarlo es muy sencillo.</p>"},{"location":"utilities/enviroments/#variables-de-entorno","title":"Variables de entorno","text":"<p>Al abrir una ventana de terminal, se inicializa un nuevo proceso zsh, que tiene sus propias variables de entorno. Estas variables son una forma de almacenamiento global para varias configuraciones heredadas por cualquier aplicaci\u00f3n que se ejecute durante esa sesi\u00f3n de terminal. Una de las variables de entorno m\u00e1s referenciadas es PATH, que es una lista separada por dos puntos de las rutas de los directorios que Bash buscar\u00e1 siempre que se ejecute un comando sin una ruta completa.</p> <p>Podemos ver el contenido de una determinada variable de entorno con el comando echo seguido del car\u00e1cter \"$\" y un nombre de variable de entorno. Por ejemplo, veamos el contenido de la variable de entorno PATH:</p> <pre><code>kali@kali:~$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n</code></pre> <p>Ahora necesitamos trabajar con el archivo .zshrc que se encontraria en la carpeta del usuario y tambien en la carperta del usuario root </p> <p>para agregar una ruta al PATH </p> <pre><code>cat .profile\n\n</code></pre> <p>![[Pasted image 20210614231636.png]]</p> <pre><code>nano .zshrc\n\n</code></pre> <pre><code>nano .zshrc\n\n</code></pre> <pre><code>pip freeze\n\n</code></pre> <pre><code>git clone https://github.com/SecuraBV/CVE-2020-1472.git\n</code></pre> <pre><code>git clone https://github.com/loseys/BlackMamba.git\n</code></pre>"},{"location":"utilities/enviroments/#pyenv","title":"Pyenv","text":"<p>Instalando Pyenv</p> <p>En este repositorio de github , nos vamos a dirijir a la seccion deinstalacion de pyenv https://github.com/pyenv/pyenv</p> <p>![[Pasted image 20210614234912.png]]</p> <p>Pero previamente me dice que instale las dependencias, por lo tanto pasamos a instalar dependencias.</p> <p>https://github.com/pyenv/pyenv/wiki#suggested-build-environment</p> <p>en este caso para debian</p> <pre><code>sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre> <p>ahora paso a clonar el repo  y lo bajo en el home directory</p> <pre><code>git clone https://github.com/pyenv/pyenv.git ~/.pyenv\n\n</code></pre> <p>Configura el entorno de tu shell para Pyenv</p> <p>Previamente procedemos agregar las variables a la .zshrc</p> <pre><code>echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrc\n\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrc\n\necho 'eval \"$(pyenv init --path)\"' &gt;&gt; ~/.zshrc\n\n</code></pre> <p>una vez agregados estas lineas a nuestra .zshrc. ehorabuena !!!!</p> <p>Felicitaciones !!! ahora tenemos pyenv</p> <pre><code>pyenv  \npyenv 2.0.1-5-gbbcecc75\nUsage: pyenv &lt;command&gt; [&lt;args&gt;]\n\nSome useful pyenv commands are:\n   commands    List all available pyenv commands\n   exec        Run an executable with the selected Python version\n   global      Set or show the global Python version(s)\n   help        Display help for a command\n   hooks       List hook scripts for a given pyenv command\n   init        Configure the shell environment for pyenv\n   install     Install a Python version using python-build\n   local       Set or show the local application-specific Python version(s)\n   prefix      Display prefix for a Python version\n   rehash      Rehash pyenv shims (run this after installing executables)\n   root        Display the root directory where versions and shims are kept\n   shell       Set or show the shell-specific Python version\n   shims       List existing pyenv shims\n   uninstall   Uninstall a specific Python version\n   --version   Display the version of pyenv\n   version     Show the current Python version(s) and its origin\n   version-file   Detect the file that sets the current pyenv version\n   version-name   Show the current Python version\n   version-origin   Explain how the current Python version is set\n   versions    List all Python versions available to pyenv\n   whence      List all Python versions that contain the given executable\n   which       Display the full path to an executable\n\nSee `pyenv help &lt;command&gt;' for information on a specific command.\nFor full documentation, see: https://github.com/pyenv/pyenv#readme\n</code></pre> <p>Procedemos a combinar el pyenv con un una herramienta la cual es un pluggin para pyenv</p> <p>https://github.com/pyenv/pyenv-virtualenv</p> <pre><code>git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv\n</code></pre> <pre><code>echo 'eval \"$(pyenv virtualenv-init -)\"' &gt;&gt; ~/.zshrc\n</code></pre> <p>Ahora vemos que version de pyenv tengo instalada </p> <pre><code>\u279c  ~ pyenv version\nsystem (set by /home/kali/.pyenv/version)\n</code></pre> <pre><code>pyenv install --list\n</code></pre> <pre><code>pyenv virtualenv 3.8.10 HTB\n</code></pre>"},{"location":"utilities/linux/","title":"Linux","text":""},{"location":"utilities/linux/#comandos-basicos-de-linux","title":"Comandos basicos de linux \ud83d\udc27","text":""},{"location":"utilities/linux/#navegacion-y-manipulacion-de-directorios","title":"Navegaci\u00f3n y manipulaci\u00f3n de directorios \ud83d\udcc1","text":"<pre><code>$ ls # lista el contenido del directorio actual\n</code></pre> <pre><code>$ pwd # muestra la ruta del directorio actual\n</code></pre> <pre><code>$ cd &lt;directorio&gt;: cambia al directorio deseado\n</code></pre> <pre><code>$ cp &lt;archivo&gt; &lt;ruta&gt; # copia archivos\n</code></pre> <pre><code>$ cp -r &lt;carpeta&gt; &lt;ruta&gt; # copia archivos y carpetas recursivamente\n</code></pre> <pre><code>$ rm &lt;archivo&gt; # elimina archivos\n</code></pre> <pre><code>$ rm -rf # elimina archivos y carpetas de forma recursiva y forzadamente\n</code></pre> <pre><code>$ mv # mueve o renombra archivos o directorios\n</code></pre> <pre><code>$ mkdir# crea un nuevo directorio\n</code></pre>"},{"location":"utilities/linux/#gestion-de-archivos-y-permisos","title":"Gesti\u00f3n de archivos y permisos \ud83d\udcc2","text":"<pre><code>$ touch &lt;nombre-del-archivo&gt; # crea un nuevo archivo vac\u00edo\n$ chmod &lt;permisos&gt; &lt;archivo&gt; # cambia los permisos de los archivos\n$ shred # sobrescribe un archivo para ocultar su contenido\n</code></pre>"},{"location":"utilities/linux/#gestion-de-procesos-y-recursos-del-sistema","title":"Gesti\u00f3n de procesos y recursos del sistema \ud83d\udda5\ufe0f","text":"<pre><code>$ htop # muestra informaci\u00f3n sobre los procesos y los recursos del sistema\n$ ps # informa sobre el estado de los procesos del shell\n$ kill # termina los programas\n</code></pre>"},{"location":"utilities/linux/#gestion-de-paquetes","title":"Gesti\u00f3n de paquetes \ud83d\udce6","text":"<p>Como manejadores de paquetes posiblemente empecemos utilizando <code>apt</code> que es parte de las distribuciones basadas en debian, como ubuntu, mint, etc. Pero en el caso de las distribuciones basadas en red hat, como fedora, centos, etc. utilizaremos <code>yum</code>.</p> <pre><code>$ apt update # actualiza la lista de paquetes disponibles\n$ apt upgrade # actualiza los paquetes instalados\n$ apt install &lt;paquete&gt; # instala un paquete\n$ apt remove &lt;paquete&gt; # elimina un paquete\n$ apt autoremove # elimina los paquetes que ya no son necesarios\n$ apt search &lt;paquete&gt; # busca un paquete\n$ apt show &lt;paquete&gt; # muestra informaci\u00f3n sobre un paquete\n</code></pre>"},{"location":"utilities/linux/#interaccion-con-el-sistema","title":"Interacci\u00f3n con el sistema \ud83d\udda5\ufe0f","text":"<pre><code>$ sudo &lt;comando&gt; # ejecuta el siguiente comando como superusuario\n$ sudo !! # ejecuta el \u00faltimo comando como superusuario\n$ shutdown &lt;tiempo-en-milisegundos&gt; # apaga la m\u00e1quina\n$ exit # sale de la sesi\u00f3n actual del shell\n$ passwd # cambia la contrase\u00f1a del usuario\n$ history # muestra una lista de comandos utilizados\n$ which &lt;programa&gt; # devuelve la ruta binaria completa de un programa\n$ uname -a # muestra informaci\u00f3n sobre el sistema operativo\n</code></pre>"},{"location":"utilities/linux/#comunicacion-y-conectividad","title":"Comunicaci\u00f3n y conectividad \ud83d\udce1","text":"<pre><code>$ ping &lt;url&gt; # comprueba la conectividad con un host\n$ wget &lt;url&gt; # descarga archivos desde la web\n</code></pre>"},{"location":"utilities/linux/#edicion-de-texto","title":"Edici\u00f3n de texto \ud83d\udcdd","text":"<p>Estos editores de texto vienen instalados por defecto y son muy \u00fatiles para editar archivos de configuraci\u00f3n.</p> <pre><code>$ vi &lt;archivo&gt; # abre el archivo en el editor de texto vim\n$ nano &lt;archivo&gt; # abre el archivo en el editor de texto nano\n</code></pre>"},{"location":"utilities/linux/#visualizacion-de-archivos-y-datos","title":"Visualizaci\u00f3n de archivos y datos \ud83d\udcca","text":"<pre><code>$ cat &lt;archivo&gt; # muestra el contenido de un archivo\n$ less # inspecciona los archivos de forma interactiva\n$ tail # muestra las \u00faltimas l\u00edneas de un archivo\n$ head # muestra las primeras l\u00edneas de un archivo\n$ grep # imprime las l\u00edneas que coinciden con los patrones\n$ wc # cuenta las palabras de un archivo\n$ find # busca archivos que siguen un patr\u00f3n\n</code></pre>"},{"location":"utilities/linux/#ayuda-y-documentacion","title":"Ayuda y documentaci\u00f3n \ud83d\udcda","text":"<pre><code>$ man &lt;comando&gt; # muestra la documentaci\u00f3n de un comando\n$ whatis &lt;comando&gt; # muestra una descripci\u00f3n corta de un comando\n$ neofetch # (necesario instalarse) muestra informaci\u00f3n sobre el sistema operativo y el hardware\n$ whoami # muestra el nombre de usuario actual.\n</code></pre>"},{"location":"utilities/linux/#documentacion-adicional","title":"Documentaci\u00f3n adicional \ud83d\udcd4","text":"<p>En ingles devhints Tambien en ingles quickref</p>"}]}